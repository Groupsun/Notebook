# LwIP概述

LwIP是一款主要应用与嵌入式领域的开源TCP/IP协议栈，且功能是完备的（对比uIP不完备的TCP/IP实现）。LwIP的实现保证了在嵌入式设备RAM、ROM资源有限的情况下实现TCP协议的主要功能，因此具有其独有的一套数据包和内存管理机制，使其能够在低端的嵌入式系统中使用。LwIP可以移指到嵌入式操作系统上运行，也可以在无操作系统的情况下独立运行，因此几十K的RAM和ROM就可以满足其运行的需求了。

LwIP的源代码开源网址：http://git.savannah.gnu.org/cgit/lwip.git/

## LwIP源代码结构

概览如下：

- **doc** - 协议栈相关的说明文档
    - rawapi.txt - Raw/Callback API编程说明文档
    - sys_arch.txt - 移植说明文档
- **src** - 包含了协议栈所有的内核代码
    - api - Sequential API以及Socket API接口函数及实现相关的源代码
    - core - LwIP内核源代码
    - include - 头文件目录
    - netif - 底层网络接口相关文件
- **test** - 协议栈内核测试程序

#### netif

netif文件夹内包含了底层网络接口的实现。

- PPP协议：PPP文件夹中具有对PPP协议实现的源代码，LwIP提供了对PPPoE(PPP for Ethernet)的支持。
- ARP协议：etharp.c包含了对ARP协议的实现。
- 以太网网卡的初始化、发送、接收函数的实现：ethernetif.c中包含了功能的实现。
- SLIP串行链路IP：slipif.c中包含了功能的实现。它提供了一种在串行链路上传送IP数据包的函数定义，移植者需要根据自己使用的串行线路特性来实现这些函数。

#### core

core文件夹包含了IP、ICMP、IGMP、TCP、UDP等核心协议以及建立在它们基础上的DNS、DHCP、SNMP等上层应用协议。

- IPv4：ipv4文件夹中包括了IPv4标准中IP层数据包处理相关的所有代码。
- IPv6：ipv6文件夹中包括了IPv6标准中IP层数据包处理相关的所有代码。
- SNMP：snmp文件夹包含了和SNMP协议实现的相关所有代码。SNMP称为简单网络管理协议，是一个基于TCP/IP协议栈的上层应用程序，在LwIP中用UDP来实现。
- IP层功能函数定义：def.c中包含了相关定义。
- DHCP客户端代码：dhcp.c包含了DHCP客户端代码。
- DNS客户端代码：dns.c实现了客户端代码。
- LwIP协议栈初始化密切相关的函数：init.c包含了协议栈初始化相关的函数，以及一些协议栈配置信息的检查和输出。
- 内存管理：mem.c包括了协议栈内存堆管理函数的实现，memp.c包含了协议栈内存池管理函数的实现。
- 协议栈网络接口管理的相关函数：netif.c包含了协议栈网络接口管理的相关函数。
- 协议栈内核使用的数据包管理函数：pbuf.c包含了协议栈内核使用的数据包管理函数
- 为应用层提供的一种直接和IP数据包交互方式：raw.c中提供，类似于Socket编程中原始套接字的概念。
- 协议栈内部数据统计与现实相关函数：stats.c中提供，如内存使用状况、邮箱、信号量等信息。
- TCP控制块操作的函数：tcp.c中提供，也包括了TCP定时处理函数。tcp_in.c包含了TCP协议中数据接收、处理相关的函数，TCP状态机也在这个文件中。tcp_out.c包含了TCP中数据发送相关的函数。
- UDP协议相关的函数：实现了UDP协议的相关函数，包括UDP控制块管理、UDP数据包发送函数、UDP数据包接收函数等。
- 借助操作系统模拟层的信号量机制完成睡眠一定时间的功能：sys.c，该函数主要在PPP中使用。
- 内核各个协议定时时间处理函数的封装：timers.c。

core文件夹下的ipv4文件夹中的内容包括了IPv4标准中IP层数据包处理相关的所有代码：

- autoip.c：包含了IP地址自动配置相关的函数，如果主机从DHCP服务器处获取IP地址失败，则此时主机可以选择启动AUTOIP功能来配置自身的IP地址。
- icmp.c：包含了ICMP协议实现的相关函数，ICMP协议为IP数据包传递过程中的差错报告、差错纠正以及目的地址可达性测试提供了支持。
- igmp.c：包含了网络管理协议IGMP的实现。

#### api

LwIP为用户提供了两种简单的上层API接口，一种是协议栈的Sequential API，另一种是Socket API。这两种API实现的原理都是通过引进邮箱和信号量等通信与同步机制，来实现内核core中的Raw/Callback API函数的封装和调用。该两种API具有更佳的封装性和易用性，但是不可避免地会降低代码地执行效率和整个系统地稳定性，并且要使用这两种API，必须基于底层操作系统提供地邮箱和信号量机制，板子上必须移植好操作系统。

- api_lib.c、api_msg.c：包含了所有Sequential API函数的实现，前者主要包含预留给用户的编程接口，后者主要包含API信息的封装与处理函数。
- netbuf.c：上层数据包管理函数的实现。
- netdb.c：包含与主机名字转换相关函数。
- netifapi.c：包含了上层网络接口管理函数的实现。
- sockets.c：包含了Socket API函数的实现。
- tcpip.c：提供了上层API与协议栈内核交互的函数。

#### include

包含了所有C文件对应的有文件声明，同时opt.h包含了所有LwIP内核参数的默认配置值，init.h包含了当前LwIP源代码信息相关的宏定义。

## LwIP框架

### 协议栈分层思想

TCP/IP分为四个层次，自底向上为：网络接口层、网络层、传输层、应用层。在所有层次中，每一层建立在低一层提供的服务上，低一层为高一层提供服务，最终完成数据在两台联网主机间的传递。

1. 网络接口层

    TCP/IP模型协议的最底层，主要负责网络上数据帧的发送和接收，其中数据帧是底层网络的基本传输单元。网络接口层将上层网络层的数据包组装成自己特定的数据帧并发送，另一方面接收网络中发给自己的数据帧，并解析出帧中的数据后递交上层网络层。

2. 网络层

    网络层负责在主机之间的通信中选择数据报的传输路径（路由）。当网络层接收到来自上层传输层的数据分组后，把分组封装在IP数据包中，填入数据包的首部，使用路由算法来确定是直接交付数据包韩式传递给路由器，然后把数据包交给适当的网络接口进行传输。

    同时网络层也要负责校验传入数据包的数据有效性，然后判断该数据包的目的主机是不是本机，如果不是，则使用路由算法转发。如果是，则需要除去数据报中的首部得到数据分组，然后将数据分组递交给上层传输层。

3. 传输层

    主要提供应用程序之间的通信服务，即端到端通信。传输层协议把上层应用层要传输的数据划分为分组，把每个分组连同目的地址交给网络层去发送。传输层要保证两端数据的准确交互，提供可靠的传输服务，以确保数据到达无差错、无乱序。传输层协议采用协商、确认、重发等机制。

4.  应用层

    作为分层模型的最高层，只利用了传输层提供的数据传输功能发送自己的数据给对方。

在标准的TCP/IP协议结构中，各个层都严格进行分层设计，每一个层负责完成一个独立的通信问题。如果按照上述严格的分层模式来实现TCP/IP协议，会使数据包在各层间的递交变得非常慢（涉及到内存拷贝的问题），从而影响到了系统性能。LwIP没有采用完整的分层结构，它假设各层间的部分数据结构和实现原理在其他层是可见的。

LwIP除了参考TCP/IP协议实现的基本TCP/IP功能模块外，还有许多支持这些基本模块实现的附加模块，如操作系统模拟层、数据包和内存管理机制，网络结构管理层、数据校验和计算模块以及API模块。

LwIP内核中的实现，操作系统代码和用户程序代码之间没有出现明显分层的现象，允许用户程序和操作系统内核之间使用更加宽松的方式进行通信（内存共享）。用户程序可以直接访问协议栈的内部数据包，也可以和协议栈共同使用一定的内存区域，对这些区域直接读或者写，避免内存拷贝的时间开销和空间开销。

### 进程模型

协议的进程模型为协议实现时被划分在几个进程中，也就是具体实现协议栈时需要几个进程。

**单进程模型**：让协议栈中的每个模块都独立地成为一个进程，在这种模式下，各个模块之间有个明显的界限区分，各个模块间的接口定义也非常清晰。但是严格的分层结构会让数据包在各个层次间递交时，设计到各个进程频繁的问题，进程间的切换开销比较大，因此单进程模型会使得协议栈的效率非常低。

**嵌入操作系统中**：另一种实现的方式是让协议栈驻留在操作系统中，成为操作系统的一部分，用户进程与协议栈内核之间进行交互就是通过操作系统提供的系统函数来实现的。

LwIP采用了协议栈内核同操作系统互相隔离的进程模型，整个协议栈作为操作系统中的一个单独进程存在。用户的应用程序可以驻留在协议栈内核的进程中，也可以实现为一个单独的进程。如果选择驻留在协议栈内核的进程中，用户程序与协议栈之间的通信时通过回调函数（Raw/Callback API）来实现的。当使用第二种方式时，需要使用协议栈中的操作系统模拟层提供的信号量与邮箱机制，实现用户进程和协议栈内核的数据交互（Sequential API和Socket API）。

将LwIP实现为操作系统上的一个单独的进程，最大的有点在于可以在任何操作系统上进行移植，缺点在于协议栈进程运行需要操作系统的调度，其实时性可能会受操作系统调度的影响。在嵌入式操作系统中使用LwIP最好将其设置为优先级最高的进程。

### 协议栈编程接口

1. Raw/Callback API

    基于Raw/Callback API来实现LwIP网络编程时，协议栈与用户程序之间通信是通过回调函数来实现的，用户程序和协议栈内核运行在同一进程中。该接口是最直接利用协议栈的方法，应用程序通过函数注册的方式与内核产生联系，在内核相关事件发生时，用户函数通过回调的方式被执行。因为两者互相处于制约状态，一旦用户程序计算量很大，有可能会使内核饥饿导致协议栈接收、处理新数据包的效率收到影响，而最严重的后果就是出现丢包。因此Raw/Callback API不适合在多任务、交互数据量大、数据处理时间开销长等场合下使用。

2. Sequential API

    LwIP协议栈API设计的出发点是上层已经预知了协议栈内核的部分结构，API可以使用这种预知来避免数据拷贝的出现。协议栈API与BSD socket具有很大相似性，它们遵循了极为相似的编程步骤，前者工作在一个更低的层次，用户进程可以直接操作内核进程中的数据包数据。协议栈内部包含了基于协议栈API实现的BSD socket编程接口。

    协议栈的API实现由两部分组成：一部分作为用户编程接口函数提供给用户，这些函数在用户进程中执行，另一部分驻留在协议栈内核进程中。这两部分通过进程通信机制（IPC）实现通信和同步（邮箱、信号量、共享内存）。API设计的核心在于让用户进程负责尽可能多的工作，而协议栈进程只负责简单的通信工作。应用程序使用netbuf结构来描述、组装数据包，该结构只是对内核pbuf的简单封装，通过共享一个netbuf结构，两部分API就能实现对数据包的共同处理，避免了数据的拷贝。

    netbuf是应用程序描述待发送数据和已接收数据的基本结构，内核为用户提供了一系列的操作函数，通过这些函数可以直接对netbuf中的数据进行读取、填写等操作。当协议栈收到数据包后，就会将数据封装在一个netbuf中，并递交给应用程序。在数据发送时，不同类型的连接将导致不同的数据处理方式。

    在当前的实现模式下，协议栈与用户应用程序运行在不同的进程上，使用邮箱和信号量等机制，内核进程可以直接将数据递交到应用程序邮箱中然后继续执行，不必阻塞等待。

3. Socket API

    套接字函数的API是对Sequential API进行封装后的产物，得到了可供用户使用的套接字函数。但是标准socket库中的部分函数仍无法直接通过封装Sequential API来实现，因此LwIP中的socket函数不完整。
