Guard Bit，也就是警戒位。在数值分析当中，可以使用一个或者多个警戒位来减少舍入的误差。

如果说一个许多步骤计算的最终结果可以安全地舍入到 *N* 位小数，那么，最终的舍入操作引入的舍入误差对整体不确定性的影响可以忽略不计。

然而，在中间步骤舍入到同样多的位数很可能是**不**安全的。 因为舍入误差可以累积。 如果中间步骤中用了 *M* 位小数，那么就有 *M−N* 个警戒位。

举例来说，有以下的定点小数运算：
$$
2^1 \times 0.100_2 - 2^0 \times 0.111_2
$$
该运算的准确结果是：$2^1 \times 0.0001_2$，也就是0.125。

如果不做任何处理，也就是不增加任何的警戒位，那么运算会这样进行：

对其位数：
$$
2^1 \times 0.100_2 - 2^1 \times 0.011_2
$$
计算结果得到：$2^1 \times 0.001_2$，也就是0.25。

如果使用警戒位来进行处理，则需要在第一个操作数中增加一位警戒位：
$$
2^1 \times 0.1000_2 - 2^1 \times 0.0111_2
$$
这样运算得到的结果是$2^{-2} \times 0.100_2$，也就是0.125。

程序代码也会如此，如下的一段C代码说明了一个由浮点舍入导致的错误：

```C
int main(){
   double a;
   int i;

   a = 0.2; 
   a += 0.1; 
   a -= 0.3;

   for(i = 0; a < 1.0; i++) 
       a += a;

   printf("i=%d, a=%f\n", i, a);

   return 0;
}
```

输出的结果是：

```
i=54, a=1.000000
```







