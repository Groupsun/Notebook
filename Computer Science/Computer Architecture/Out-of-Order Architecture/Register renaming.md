# Register renaming

在计算机体系结构当中，寄存器重命名是一种技术来消除数据依赖的方法，通过重用一组连续的指令所使用的寄存器，它们之间不存在数据依赖。通过消除这些负面的数据依赖，可以揭示在指令流中更多的指令级别并行执行的相关内容，从而可以被多种技术作为补充以获得更好的性能，如超标量以及乱序执行处理器。

## 问题描述

在寄存器机中，程序由操作数据的指令构成。指令必须对这些值命名来分辨它们。一种典型的指令会说：将X和Y的值相加并且将结果放在Z中。在这条指令当中，X，Y，和Z都是存储位置的名字。

为了获得紧凑的指令编码，绝大多数的处理器指令集拥有一个小的特殊存储位置的集合可以被直接命名（通用寄存器）。比如，在x86指令集架构当中，有8个整型寄存器，x86-64有16个，大多数的RISC机有32个，IA-64有128个。在小型的处理器当中，这些寄存器一般组合寄存器组的机构。

不同的指令可能会需要执行不同的时间。比方说，一个处理器可能能够在一个从主存中读取数据的指令所需要的时间里，执行上百条其他的指令。因此，这些执行速度更快的指令会在load指令执行完成前先执行完毕，这时候指令真正执行的顺序就会和原来的程序有出入。乱序执行已经在现在的高性能CPU上使用了。

考虑在一个乱序执行的CPU上执行下列指令序列：

```
01  R1 = M[1024]
02  R1 = R1 + 2
03  M[1032] = R1
04  R1 = M[2048]
05  R1 = R1 + 4
06  M[2056] = R1
```

指令4,5,6与指令1,2,3是相互独立的，但是指令4不能在指令3完成前先完成，否则指令3会写入错误的值。这样的约束可以通过重命名寄存器的名字来消除：

```
01  R1 = M[1024]        04  R2 = M[2048]
02  R1 = R1 + 2         05  R2 = R2 + 4
03  M[1032] = R1        06  M[2056] = R2
```

现在，指令4,5,6可以与指令1,2,3并行执行，因此这个程序现在可以执行的更快了。

如果可能的话，编译器会检测不同的指令然后尝试去给它们分配不同的寄存器。然而，这里只有有限的寄存器名字可以在汇编代码中使用。很多高性能的CPU有更多的物理寄存器可以在指令集中被直接命名，因此在硬件中进行重命名寄存器操作可以获得额外的并行性。

## 数据冒险

数据冒险有三种：RAW、WAW以及WAR（分别是什么意思不再赘述，可以参考RISC-V构建相关笔记参考或者直接google即可），下面阐述的是另外一种表述的方式：

- 写后读（Read-after-write，RAW）：从寄存器或者内存中读取的数据，必须是先前最后一个写指令写入的数据。这种依赖也称为直接依赖或者流依赖（或者真依赖？，原文：ture dependency or flow dependency）。这种依赖（冒险）的解决方法可以通过使指令按照程序顺序来执行。

- 写后写（Write-after-write，WAW）：连续写入同一个寄存器，寄存器的最终结果必须等于最后一次写入的值。这种依赖也称为输出依赖。这种依赖（冒险）的解决方法可以通过取消（无效）先前的写指令来解决。

- 读后写（Write-after-read，WAR）：读操作获得的数据是此前写入的，而不是此后写操作的结果。这种依赖也称为假依赖（false dependency），可以通过重命名来解决。WAR依赖也可以被称为反依赖（anti-dependencies）。

不同于在所有的读完成之前都将写操作进行延时，目标存储地址的两个拷贝可以被维护：旧的以及新的拷贝。这样，在写之前的读就可以提供旧的值，而在写之后的读就可以提供新的值。这样做，假依赖被大破，并且额外的乱序执行的机会得以创造出来。当所有的读取都已经完成了，旧的值就可以被丢弃。这是寄存器重命名的必要概念。

所有读取以及写入的位置都可以被重命名。最常见的是重命名通用寄存器以及浮点寄存器，标志以及状态寄存器甚至独立的状态位也可以被重命名。

存储器重命名同样可行，虽然没有寄存器重命名那么常见。在Transmeta Cursoe的处理器中门存储缓存可以使用存储器重命名技术。

如果程序可以不立即重用同一个寄存器，那么就没必要进行寄存器重命名了。一些指令集提供大量的寄存器就是为了这个目的。但是这种做法也有它的局限性：

- 编译器很难完全避免在不导致程序尺寸大增的同时避免重用寄存器。在循环当中，连续的迭代执行需要复制循环体的代码以使用不同的寄存器，这种技术叫做循环展开。

- 大量的寄存器需要在指令中使用更多的比特位来指定寄存器，这样也会增大代码量。

- 很多指令集在此之前只有比较少的寄存器，同时在新的架构中实现也不能扩大寄存器的数量（没有向后兼容的特性）。

代码量的增加是很重要的，因为当程序代码变大之后，指令缓存未命中的概率会增大，处理器停滞以等待新指令的时间会变多。

## 体系结构寄存器与物理寄存器

很多的机器语言程序所指定的用于读写的寄存器都受限于在指令集中指定的寄存器。举例来说，在Alpha当中声明了32个整数寄存器，每一个都是64位宽，以及32个浮点寄存器，每一个也是64位宽。这些是体系结构寄存器。使用Alpha指令集写的程序指令会指定读写这64个寄存器。

Alpha 21264（1996年由DEC设计的RISC处理器），实现了Alpha指令集，且物理上拥有80个整型寄存器以及72个浮点寄存器。（事实上，还有更多的寄存器，只是这些寄存器都不能用于寄存器命名操作）

接下来就描述两种寄存器命名的类型，可以利用为数据提供执行的电路来进行区别。

在所有的重命名的策略当中，机器会将体系结构寄存器根据指令流转换成标签。体系结构寄存器可能会使用3到5个比特位来进行描述，而标签通常使用6到8个比特位来进行描述。重命名的部件必须拥有读取的端口对应每个时钟周期中重命名的每个指令的每个输入，同时还必须拥有一个写入的端口对应每个时钟周期中重命名的每个指令的每个输出。因为寄存器组的大小一般来说都会以读写端口的个数平方增长，而重命名的器件一般会在物理上要更大并且拥有更大的功率。

1. 在标签索引的寄存器组类型（tag-indexed register file）中，存在一个大的寄存器组给数值存放，所有的寄存器都可以打上标签。举例来说，如果机器拥有80个物理寄存器，那么这里应该使用7位的标签。在这个例子中，有48个可能的标签值没有被使用。

    在这种类型当中，当一个指令发射给一个执行单元的时候，这个源寄存器的标签会发送给物理的寄存器组，这些标签对应的值会被发送给执行单元。

2. 在保留站（reservation station）的类型当中，有很多小的相关的寄存器组，通常在每个执行单元的每个输入都有一个。发射队列中的每条指令的每个操作数对应着这个物理寄存器堆的一个存储位置。

    在这种类型当中，当一条指令发射给一个执行单元的时候，执行单元对应的寄存器堆的相应条目被读出发送给执行单元。

**体系结构寄存器组与隐退寄存器组**（Retirement Register File，RRF）

存储了被提交了的寄存器状态的寄存器组。存储了被提交的体系寄存器的状态。通过逻辑寄存器的号来查询这个寄存器组。重排序缓冲区（reorder buffer）中的引退（retired）或者说提交（committed）指令，把结果写入这个寄存器组。

**远期寄存器组**（Future File）

处理器对分支做预测执行的寄存器的状态保存于此。使用逻辑寄存器号来索引访问。在Intel P6微体系结构，称之为Active Register File。

**历史缓冲区**（History Buffer）

一般来说和远期寄存器组一起使用。包含已经被覆写的寄存器的旧的值。如果分支预测失败，使用历史缓冲区中的数据来恢复流水线。

**重排缓冲区**（Reorder Buffer，ROB）

为了实现指令的顺序提交，处理器内部使用了一个Buffer。如果在该缓冲区中排在一条指令之前的所有都已经提交，没有处于未提交状态的（in flight），则该指令也被提交。因此重排缓冲区是在远期寄存器组之后，体系结构寄存器组之前。提交的指令的结果写入体系寄存器堆。

重排缓冲区可以是data-less或者是data-ful的。

在Willamette的ROB结构当中，ROB的每个项都指向一个物理寄存器组（Physical Register File，PRF）中的寄存器，同时还包括一些簿记数据。这是第一种乱序设计，由Andy Glew在Illinois使用HaRRM完成。

在Intel P6的ROB结构当中，ROB的每个项都包含数据，而没有分离的PRF结构。来自ROB的数据在提交后会被复制到RRF。

## 标签索引寄存器组的实现细节

这种重命名的方式在MIPS R10000（实现MIPS IV指令集的RISC处理器，在1996年由MIPS科技有限公司设计）、Alpha 21264以及AMD Athlon（AMD在1999年中期到2005年生产的x86处理器）的浮点运算部件中使用。

在重命名的阶段当中，每个被引用的体系结构寄存器（不论是读还是写）按其体系结构索引号到重命名文件（remap file）中查找。这个文件会返回一个标签以及一个准备位。如果有一个队列中的指令要写这个寄存器，且还没有完成，那么这个标签还没准备好，还不能被使用。

- 对于读取操作来说，这个标签将会取代在指令中的体系结构寄存器，也就是说，写后读的数据相关必须恪守，读操作只有在该标签的ready位是就绪的时候才能执行。

- 对于写入操作来说，从一个FIFO的空闲标签队列中取出一个标签，然后一个新的映射条目写入重命名文件，未来的读取该体系结构寄存器的指令将指向这个新的tag。在这种情况下，可以发现，WAW是一种寄存器数据的假依赖，用这种重命名的方法就可以去掉假依赖。因为以前为该体系结构寄存器分配的物理寄存器被保存在指令的重排缓冲区，根据写入的tag（此时tag未就绪，写操作尚未执行），由于重拍缓冲区是一个FIFO的队列，根据指令的阶码顺序安排指令引退，只将最后一条有效的写的指令执行即可。

操作数寄存器被重命名后的指令将被放入不同的发射队列（issue queues）。这些指令等待所需的各种资源（源操作数对应的物理寄存器）就绪。

当发射队列中的某条指令的素有操作数都是就绪的，这条指令就是发射就绪。在每个周期，发射队列挑选出一些就绪的指令，发射到功能单元。未就绪的指令仍然留在发射队列中。这种从发射队列中无序删除指令，使得发射队列的电路实现占用面积大、功耗高。

被发射的指令读取源操作数的tag索引在物理寄存器堆中对应的物理寄存器（忽略掉刚刚公告过的操作数），然后开始执行指令。

指令执行结果写入目的操作数的tag索引在物理寄存器堆对应的物理寄存器，同时公告给每个功能单元输入端的旁路网络（bypass network，即把执行结果“直通”给流水线各个步骤的中间缓冲）。

写寄存器的指令在引退时，把被写的目的操作数寄存器使用过的上一个tag放入“空闲tag队列”中，使得它可以被其它被解码的指令重用。而该指令的目的操作数寄存器当前对应的tag仍然被占用，因为后面可能还有指令需要读取当前tag对应的物理寄存器的内容。

一个异常（将导致中断）或者分支预测失败导致了重命名文件退回到最后一条有效的指令的重命名状态，通过组合状态的快照（在历史缓冲区）与重排缓冲区中等待顺序引退的指令的以前用过的tags。这种机制可以实现恢复任意时刻的重命名状态。

## 保留站的详细实现

保留站的实现在AMD K7以及K8的整数执行部分中使用。

在重命名阶段中，每个体系结构寄存器会从远期寄存器组以及重命名文件中查找对应的物理寄存器。如果没有写指令还没有完成写入该物理寄存器，则说明这个源操作数已经就绪。当这条指令被放入发射队列，从远期寄存器堆相应的物理寄存器读出内容放入保留站中对应的条目。指令对目的寄存器的写入，在重命名文件中的产生了一个新的、未就绪的tag。tag数通常是按照指令的顺序分配，因此不需要空闲tag先进先出队列。

如同tag索引模式，发射队列中的未就绪操作数等待匹配的tag公告。但不同于tag索引模式，tag的匹配导致对应的内容数据写入发射队列对应的保留站的条目。

被发射的指令从保留站读取它的操作数，忽略掉那些刚刚公告过的操作数，然后开始执行。保留站寄存器堆通常很小，可能只有8个条目。

指令执行结果写入重排缓冲区，以及保留站（如果发射队列有匹配的tags），以及远期寄存器堆。

指令引退时，复制重排序缓冲区中的值到体系结构寄存器堆。体系结构寄存器堆用于从异常或者分支预测失败时恢复。

在指令引退时可以识别出异常与分支预测失败，引起体系结构寄存器堆覆盖掉远期寄存器堆的内容，并标记重命名文件中所有寄存器都是就绪。通常，没有办法为一条处于解码与引退之间的指令恢复远期寄存器堆，因此通常没有办法在更早期为分支预测失败做恢复工作。

## 比较两种策略

在两种策略中，指令都是有序的插入发射队列当中，但是以乱序移除。需要考虑的是，当多条指令都可以发射的时候，需要一个或者多个优先级的编码方式。

保留站具有更好的延迟性能，因为保留站直接获取数据，而不是根据标签再获取数据。

保留站具有更好的从指令发射到执行的延迟性能。因为每个本地寄存器堆远小于那种大型的用tag索引的中央寄存器堆。tag产生与异常处理也更为简单。

与tag索引的简单的寄存器堆相比，保留站的物理寄存器堆的总规模更大，功耗更大，更为复杂。更糟糕的是，每个保留站的每个条目可以被每条结果总线写入。例如，每个功能单元具有8条发射队列条目的处理器，相比于tag索引的模式有9倍的旁路网络，结果直通（forwarding）需要更大的功耗与面积。

保留站模式在4个位置（远期寄存器堆，保留站，重排序区、系统结构寄存器堆）保存结果值。而tag索引模式只需要在物理寄存器堆保存结果值。由于结果值来自功能单元，保留站模式必须公告结果到许多存储位置，用掉了非常多的功耗、面积、时间。如果处理器具有非常精确的分支预测、非常关注执行延迟，保留站也是个很好的选择。
