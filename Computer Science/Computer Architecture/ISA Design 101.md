# ISA Design 101

计算机架构师在设计ISA时应该遵循的原则以及利弊权衡。首先列举以下的7个衡量指标：

- 成本（cost）
- 简洁性（simplicity）
- 性能（performance）
- 架构与实现之间的分离（isolation of architecture from implementation）
- 提升空间（room for growth）
- 程序大小（program size）
- 易于编程/编译/链接（ease of programming/compiling/linking）

## 成本

处理器被实现为集成电路的形式，一般称为芯片（chips）或者晶粒（dies）。之所以被称为晶粒，这是因为处理器生产从一块单一的圆形晶圆切割成许多独立的晶粒得到。因此，成本对于晶粒的面积是非常敏感的：

$$ cost \approx f(die \, area^2) $$

显然，晶粒的大小越小，一块晶圆所能切割出的晶粒数量越多，并且大多数的成本来自于对晶圆本身的处理。一个不太准确的说法是，晶粒的大小越小，晶粒的产率越高。因为硅片生产商在处理晶粒的时候会在晶圆上留下一小部分的瑕疵，因此晶粒的大小越小，那么晶圆的利用率就越高。

一个指令集的架构师会设法使指令集架构足够简洁，来使得实现的处理器的大小足够小。

## 简洁性

鉴于成本对于复杂度的敏感性，架构师需要一个简单的ISA来缩小芯片面积。一个足够简洁的指令集架构可以缩短芯片设计以及验证的时间，这些时间可以占据芯片生产过程的大部分成本。这些成本必须要加在芯片的总的生产成本中。简洁性还会影响文档的大小以及用户理解该ISA的难易程度。

## 性能

除去一些面向嵌入式系统的迷你芯片以外，一般来说架构师还需要考虑性能的问题。性能可以被3个项相乘所得到：

$$ \frac{instructions}{program} \times \frac{average clock cycles}{instruction} \times \frac{time}{clock cycle} = \frac{time}{program} $$

也就是说，决定处理器性能的有三方面的因素：程序的平均指令数、每条指令执行的平均周期数以及每个时钟周期的长度。

## 架构以及实现之间的分离

对架构以及实现之间的分离，可以最早追溯到上世纪60年代。当时架构指的是一个机器语言的程序员需要知道如何去写一个正确的程序，但是不能保证该程序的性能。对于一个架构师来说，一件颇具诱惑的事情是，为了提高某些特定时间中的特定功能实现的效率，而加入新的指令，然而这在会在未来的实现中带来不必要的困难。

举一个令人遗憾的例子来说，就是在MIPS-32当中所引入的延迟分支技术。当时MIPS的设计人员针对条件分支所带来的控制冒险问题，使用延迟分支的方法（有时也称为分支延迟间隙）来解决。它将条件分支的指令重新定义，将其定义为在条件分支指令下一条指令执行完后才发生，程序员或者编译器通过在这个周期的间隙中加入有用的指令来执行。

然而，这个所谓的解决方案对于之后流水线级数更深的MIPS处理器来说没有作用，而且还使得MIPS-32的程序员、编译器的编写人员以及处理器的设计者更难受，并且难以看懂MIPS-32的汇编代码。

这个例子告诉我们，架构师不能将一些只会对当前一个实现有帮助的特性加入到指令集当中，
同时，架构师也不应该放入阻碍某些实现的功能。例如，ARM-32和其他一些ISA具有
Load Multiple指令。这些指令可以提高单发射流水线设计的性能，但会降低多发射流水线的
效率。原因在于这种直截了当的实现排除了与其他指令并行地调度Load Multiple的各个负
载的可能，从而降低了这些处理器的指令吞吐量。

## 提升空间

随着摩尔定律的放缓，对指令集的成本-性能提升的唯一出路是在其中增加一些专为特定领域所使用的定制指令，比如深度学习、强化现实、组合优化、图形学等等。这意味着在今天，ISA对于保留一定的操作码空间是非常重要的。

在上世纪的70、80年代，当时摩尔定律还在如日中天的时候，很少有架构师会有为操作码保留空间的想法，与此相反，架构师重视更长的地址以及立即数字段来减少每个程序平均的指令数，也就是之前所提到的三个因素中的第一个因素。

一个缺乏操作码空间所带来的冲击的例子就是，ARM-32与Thumb的例子。当时，ARM-32的架构师想尝试去降低代码大小，它们想在标准的32位长度的ISA中增加16位长度的指令，但是由于指令中已经没有空间进行压缩了，因此他们只能够创造一个新的16位ISA（Thumb），然后同时用 16 位指令和 32 位指令来组成另外一个ISA（Thumb-2），它们与ARM ISA之间可以通过一个模式位来进行切换。切换的方式是通过在地址的最低位设为1来实现，这是因为16位和32位的地址中这一位必然为0。

## 程序大小

程序的大小越小，则在芯片上的程序存储器所需要的空间就越小，这在嵌入式设备中是一个显著的成本开销。因此，这个因素促使ARM的架构师后来在Thumb以及Thumb-2中增加更短的指令。更小的程序同时还会使得指令缓存的命中率更高，节省更多的功耗，因为访问片外的DRAM所需要功耗要比访问片内的SRAM更高。同样，这种做法也能提升性能。更小的代码大小是ISA架构师的重要目标之一。

x86是变长的指令集架构，x86-32具有短至1个字节的指令，长至15个字节的指令。大多数人可能会认为，使用可变长度指令的指令集所书写的程序，肯定比使用如32位定长指令集，如ARM-32和RISC-V所书写的程序大小要小。从逻辑上来说，8位的可变长指令集所写出来的程序同样比只提供16位和32位的定长指令集，如Thumb-2和RV32C，所写出来的程序要小。事实上，同一个程序，ARM-32以及RISC-V的代码大小要比x86-32要分别大6%以及9%，然而x86-32却要比压缩版本的要大26%（RV32C和Thumnb-2）。

一个具有8位可变长度的ISA确实要比使用RV32C和Thumb-2所写的程序代码长度要更小，但是在上世纪70年代，x86的架构师有着不同的想法。为了使指令日益增加的ISA达到向后二进制兼容性的要求，大量x86-32的指令比原来所期望的要更长，因此它们只能使用原x86中的操作码空间。

## 易于编程/编译/链接

由于在寄存器中的数据访问速度远比访问内存中的数据快，因此对于编译器来说，好的寄存器分配策略更为关键。因此，如果指令集中提供的寄存器越多，那么这项工作就越简单。因此，大多数的RISC都拥有大量的指令集，RISC-V中有32个（RV32I），ARM-32中有16个，而x86-32中只有8个。更多的寄存器能够使编译器以及汇编程序员更为好受。

对于编译器和汇编程序员来说，另外一个问题是如何弄清楚一个代码序列执行的速度。RISC-V的指令典型的执行速度是1个指令最多1个时钟周期（忽略缓存未命中的情况）。然而ARM-32和x86-32有很多的指令需要很多个时钟周期才能执行完毕（甚至是在所有缓存命中的情况下）。况且，x86-32还具有直接在内存中进行操作的指令（不同于加载存储架构的RISC-V，对内存的操作只能是读取和写入内存）。在内存中复杂的指令和操作会使得处理器的设计者难以预测处理器的执行性能。

对于ISA来说，支持位置无关代码（position independent code，PIC）是有用的。因为这样就可以支持动态链接，原因在于共享的库代码可以驻留在不同程序的不同地址上。因此，与PC相关的分支和数据寻址对于PIC来说是一大福音。虽然几乎绝大多数的ISA都提供了PC相关的寻址模式，但是x86-32和MIPS-32并没有提供。
