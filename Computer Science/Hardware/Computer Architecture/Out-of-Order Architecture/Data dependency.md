# Data dependency

数据依赖是计算机科学中有关程序表达式（指令）所引用的数据之间的依赖性的称呼。在流水线化/并行化的微处理器架构中是一个重要的解决课题。在编译原理中，依赖性分析用于挖掘在指令之间的依赖性，达到在软件层面上的数据依赖性的消除（数据冒险/冲突的解决）。

## 阐述

假设表达式$S_1$和$S_2$，如果下列条件成立，则$S_2$依赖于$S_1$：

$$ [I(S_1) \bigcap O(S_2)] \bigcup [O(S_1) \bigcap I(S_2)] \bigcup [O(S_1) \bigcap O(S+2)] \neq \emptyset $$

其中：

- $I(S_i)$是一组被$S_i$读取的存储地址集合（存储地址包括寄存器地址和主存地址）
- $O(S_j)$是一组被$S_j$写入的存储地址集合
- 并且存在一条从$S_1$执行到$S_2$的可行执行路径

这个条件称为伯恩斯坦条件（Bernstein Condition），以A.J.伯恩斯坦的名字命名。

在上述的条件当中存在有三个子条件，只要其中一个条件成立则两表达式之间就存在数据依赖：

- 自依赖（Anti-dependence）：$I(S_1) \bigcap O(S_2), S_1 \to S_2$并且$S_1$在$S_2$写入之前进行读取。
- 流（数据）依赖（Flow/Data dependence）：$O(S_1) \bigcap I(S_2), S_1 \to S_2$并且$S_1$在$S_2$读取之前进行写入。
- 输出依赖（Output dependence）：$O(S_1) \bigcap O(S_2), S_1 \to S_2$并且两个表达式都要写同一个存储器地址。

### Flow dependency

流依赖，又被称为数据依赖或者说是真/直接依赖（true dependency），或者叫做写后读依赖（Read-after-write，RAW），发生在一条指令所要读取的数据/源操作数来自于先前指令所要写入的寄存器的值：

```
1. A = 3
2. B = A
3. C = B
```

之所以被称作真依赖，是因为这个依赖是真实存在的，无论是顺序流水线还是乱序流水线的处理器，都需要处理RAW。在顺序流水线当中，处理RAW的方式是旁路或者停滞流水线。在乱序流水线当中，处理RAW的方式是要保证存在RAW的指令按照程序原始的顺序执行。

### Anti-dependency

一个自依赖，也被称为读后写（Write-after-read，WAR），发生在一个指令需要读取的数据在之后要被更新（写入）。在下面的例子中，指令2与指令3是自依赖的。在顺序流水线中不需要考虑WAR冒险，但是在并行或者乱序执行的流水线当中，则需要考虑这个问题：

```
1. B = 3
2. A = B + 1
3. B = 7
```

如果不做特别的措施，那么在并行或者乱序执行的流水线当中要保证指令2要在指令3之前执行。然而，一个自依赖实际上是名字依赖（name dependency）的经典例子，那是因为，只需要对变量进行重命名就可以移除依赖：

```
1. B = 3
N. B2 = B
2. A = B2 + 1
3. B = 7
```

此时，指令2和指令3的自依赖被消除了，可以乱序执行。因此，乱序流水线/托马苏洛算法中的寄存器重命名技术可以消除WAR冒险。然而，这样的修改会引入新的依赖性，指令N和指令2、指令1和指令2之间有了流依赖。但是这些冒险不能够安全的移除。

### 输出依赖

一个输出依赖，也成为写后写（Write-after-write，WAW），在连续的指令写入同一个寄存器会发生（广义上，也可以指相近的几条写同一个寄存器的指令，共同点是，真正能够使寄存器状态修改生效的只有最后一条写的指令）。

输出依赖的解决，在寄存器重命名中，通过取消先前的写入（重拍缓冲区的指令引退）可以消除输出依赖。
