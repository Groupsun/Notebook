# Exceptions

在处理器的设计当中，控制单元及其信号的设计是最具有挑战性的：它是处理器设计当中最困难的部分，并且要想加快其运行速度需要付出更大的努力。在控制单元的设计当中一个重要且关键的工作就是对异常以及中断处理的实现——不是分支指令，但是同样会改变程序正常的指令执行流。异常用于处理非期望的（不能预料的），如一个未定义的指令。与之相同的基本机制拓展用于IO设备与处理器之间进行交流。这将会在后续的章节中提到。

异常（Exception），也称为中断（Interrupt）。是一种不定期的事件，它会中断当前程序的执行，用于检测未定义的指令。异常和中断有时候可以混用，但是很多时候，中断一般指来自处理器外部的异常事件，如IO。因此，区别异常和中断的是异常事件来自于处理器的内部还是外部。如果异常事件来自于处理器的外部，那么这是一个中断，否则，这是一个异常。

实际上，很多体系架构的设计者并不能很好的分辨中断和异常，因此他们会使用其他的名字来引用这些异常和中断。距离来说，在Intel x86中统一使用的是中断。在RISC-V当中，使用异常来代表所有不能预料的，会对控制流发生改变的事件，且这些事件无法很好的进行分辨是外部的还是内部的事件。只有当这个事件明确是由外部事件引发的，才将其称作中断：

<table>
    <tr>
        <th>事件类型</th>
        <th>来自</th>
        <th>RISC-V术语</th>
    </tr>
    <tr>
        <th>系统重启</th>
        <th>外部</th>
        <th>异常</th>
    </tr>
    <tr>
        <th>IO设备请求</th>
        <th>外部</th>
        <th>中断</th>
    </tr>
    <tr>
        <th>用户程序调用操作系统</th>
        <th>内部</th>
        <th>异常</th>
    </tr>
    <tr>
        <th>使用未定义的指令</th>
        <th>内部</th>
        <th>异常</th>
    </tr>
    <tr>
        <th>硬件故障</th>
        <th>其他</th>
        <th>其他</th>
    </tr>
</table>

在很多特定的情况下，对异常的需求都会导致一个异常事件产生。这方面的话题将在后续说明，届时我们将会更好的去了解异常机制更多的功能。在这一节当中，我们所要解决的是实现对一部分指令集以及实现中所产生的异常类型的检测以及处理。

检测异常以及采取适当的措施通常对处理器的性能以及时序带来很大的影响。如果在设计控制单元中没有给异常足够的重视，在一个错综复杂的实现当中添加异常处理将会显著的降低性能，同时也会使设计难以得到正确的结果。

## RISC-V架构如何处理异常

[SEPC]: ../RISC-V特权级架构概述.md
[SCAUSE]: ../RISC-V特权级架构概述.md

当前我们的实现当中，可能出现的异常只有两种：执行一条未定义的指令以及硬件故障。我们假设硬件故障发生在指令ADD x11, x12, x11当中，接下来的讨论将会基于这个假设。当异常发生时，处理器必须要做的一项基本的工作就是将当前指令的地址保存在[SEPC]（Supervisor Exception Program Counter，特权级异常程序计数器）中，并且将控制权转移给操作系统。操作系统可以采取一些适当的措施，比如执行一些预定义的程序（这些预定义的程序一般放在特定的地址空间当中）来应对这个故障，或者直接停滞程序的执行并且回报一个错误。在执行完必要的操作之后，操作系统会停止或者继续执行先前的程序，取决于SEPC中的信息，来重启程序的执行（SEPC中的地址有可能在操作系统异常处理程序中发生了改变）。

对于操作系统来说，要处理异常，就必须要知道异常发生的原因，还有就是导致异常发生的是什么指令。有两种主要的方法来指示发生异常的原因是什么。在RISC-V体系架构中使用的方法是使用[SCAUSE]（Supervisor Cause Register，特权级异常来源寄存器），用于保存指示当前异常原因的值。

另一种方法就是使用中断向量（vectored interrupt），中断设备根据中断向量将找到中断服务程序执行。中断向量可以认为是中断服务程序的首地址，但在某些实现当中，它作为中断源的识别标志，可用来形成相应的中断服务程序的入口地址。总的来说，中断向量是硬件根据当前中断产生原因生成的硬件码（要与中断向量地址区别开来，中断向量地址是中断向量表的地址）。中断向量一般会与某个基址寄存器中的值相加来指示中断服务程序的地址（意味着在内存空间中存在一个区域专门存放着中断服务程序）。比如，在我们的实现当中，可以定义中断向量表如下：

<table>
    <tr>
        <th>异常类型</th>
        <th>中断向量</th>
    </tr>
    <tr>
        <th>未定义指令</th>
        <th>00 0100 0000</th>
    </tr>
    <tr>
        <th>系统错误（硬件故障）</th>
        <th>01 1000 0000</th>
    </tr>
</table>

其中中断向量与中断向量表基地址寄存器相加可以形成中断服务程序的地址，操作系统通过产生的地址得知异常发生的原因。如果不使用中断向量的方法，如在RISC-V架构当中，一个单一的公共中断服务程序入口会提供给所有的异常，操作系统会将状态寄存器（scause）中的值进行译码来得知造成异常的原因是什么。在使用中断向量的体系架构当中，中断向量之间可能相隔32个字节的空间，因此操作系统需要记录下异常发生的原因，并且在这32个字节空间（8个指令中）执行一些限制的操作。

我们可以为我们的处理器实现添加几个额外的寄存器以及控制信号来支持异常处理。假设我们实现的异常处理系统当中，单一的中断入口地址是${0000 0000 1C09 0000}_{hex}$。并且，我们需要增加两个额外的寄存器：

- SEPC: 64位寄存器来保存发生异常的指令地址。（这个寄存器即使是在使用中断向量的情况下也是必要的）
- SCAUSE： 64位寄存器来记录异常发生的原因，尽管该寄存器中64位有很多位都没有被使用。假设该寄存器上有一个域来编码上述两种可能的异常来源，包括2种编码代表未定义的指令，以及12种编码代表硬件故障。
