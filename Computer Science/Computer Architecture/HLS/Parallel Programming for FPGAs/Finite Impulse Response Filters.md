# 有限脉冲响应滤波器

# 概览

有限脉冲响应（Finite Impulse Response，FIR）滤波器在数字信号处理（digital signal processing，DSP）应用领域当中是非常常用的。它非常适合实现为硬件的形式，因为它们的实现可以是高度优化的结构。主要体现在它们是对连续信号元素的线性变换，这对于一些数据结构来说很容易进行映射（比如FIFO或者抽头延迟线），而这些数据结构也可以很容易的在硬件上高效实现。

滤波器的两种基本的使用是用于信号的重建（signal restoration）以及信号的分离（signal separation）。一般来说信号的分离更常使用：对一个输入的信号分离成两个不同的部分，比如，我们可能想用一个低通的滤波器（low pass filter）来除去我们不感兴趣的高频信号。或者我们想使用一个带通滤波器（band pass filter）来得到我们想要的特定频率的信号，在频移键控解调（frequency shift keying dmodulation）过程中隔离频率。信号的重建是指除去可能混入信号中的噪声或者其他失真，比如在无线链路之间的信号传输。信号的重建包括平滑信号以及移除信号的直流部分。

数字FIR滤波器经常用于处理从连续信号中采样到的离散信号。采样的方式有很多种，可以是时间（以固定时间使用AD转化采样天线的电压），也可以是空间（采样由光电二极管组成的图像传感器不同位置的值）。

采样得到的数据的格式根据场景的不同而不同。数字通信一般使用复数来表示一个样本，而在图像处理中一般将一个像素点看作一个样本（RGB值）。

# 背景知识

对给定输入脉冲信号的滤波器的输出信号是称为滤波器的脉冲响应（impulse response）。一个线性时不变的FIR滤波器包含该滤波器所有的信息。顾名思义，FIR滤波器（严格的线性时不变系统）的脉冲响应是有限的。在已知一个FIR滤波器输出相应的前提下，可以通过卷积（convolution）的方法算出该滤波器对于任意输入信号的输出响应。这个运算过程结合脉冲相应的样本（也称为系数或者阶）以及输入信号的样本来计算输出信号。滤波器的输出也可以通过其他方式进行计算(例如，通过频域计算)，在本章中，我们关注时域计算。

在解释FIR的原理之前，首先要简要了解一下有关[卷积](../../../../Mathematics/Convolution.md)的知识。

一个N-阶的FIR滤波器，其输入的信号序列为x，且系数为h，则其输出的可以由x以及h的离散卷积来表示：

$$ y[i] = \sum_{j=0}^{N-1} h[j] \cdot x[i-j] $$

可以注意到，计算N-阶滤波器的输出信号需要N次乘法以及N-1次的加法。

如果使用的是一个N-阶的滑动均值滤波器（moving average filters），那么输出信号可以表示为：

$$ y[i] = \frac{1}{N} \sum_{j=0}^{N} x[i-j] $$

每个输出信号都可以通过上述的方程使用N-1次加法以及最后与1/N相乘的乘法计算得出。显然，滑动均值滤波器要比一般的FIR滤波器的计算要更简单。比如，当N=3时，我们使用下列的公式来计算y[12]：

$$ y[12] = \frac{1}{3} \cdot (x[12]+x[11]+x[10]) $$

这个过滤器是一个因果系统（causal），意味着它的输出只与之前的输入值有关（x[10]、x[11]以及x[12]）。但是这个因果的特性是可以改变的，比如，可以以采样的中间时刻来处理，则有：$ y[12] = \frac{1}{3} \cdot (x[11]+x[12]+x[13]) $。虽然对于系统分析来说，因果是一项很重要的特性，但是在硬件实现上却并不是如此。一个非因果的有限滤波器可以使用缓存以及数据的重排列实现因果的转换。

滑动均值滤波器可以用来平滑信号，比如移除一些随机的噪声（一般来说频率比较高）。阶数N越大，则平均将会基于数量更大的样本，当然此时我们需要做更多的运算工作。对于滑动均值滤波器来说，阶数N越大表示输出信号带宽的减小。本质上来说，它的行为和一个低通滤波器相似（虽然不是最优的）——直觉上确实也是这样，这种平滑的行为也就是在减少高频的信号输出。

滤波器的系数可以改变来实现不同种类的滤波器：低通、高通、带通。更大的阶数则代表着设计滤波器时更大的自由度。以上面滑动均值滤波器的例子来说，滤波器的结构或者特定的系数可以对计算所需要的操作带来很大的影响。比如，一些对称的滤波器会含有多个相同的系数进行分组来降低乘法运算的次数。在其它的情况下，可以将乘法运算转化为移位以及加法运算。在这种情况下，系数的值可以大幅度的改变滤波器实现的性能以及面积需求。

# 基本的FIR架构

考虑下面的11阶FIR滤波器代码：

```C
#define N 11
#include "ap_int.h"  

typedef int coef_t;
typedef int data_t;
typedef int acc_t;

void fir(data_t *y,data_t x){
    coef_t[N] = {
        53,0,-91,0,313,500,313,0,-91,0,53
    };
    /* 静态数据，shift_reg需要反复使用 */
    static
    data_t shift_reg[N];
    acc_t acc;
    int i;
    acc = 0;
    Shift_Accum_Loop:       /* <- 不是必须的，但是可以方便Vivado HLS工具进行调试 */
    for(i = N - 1;i >= 0;i--){
        if(i == 0){
            acc += x * C[0];
            shift_reg[0] = X;
        }else {
            shift_reg[i] = shift_reg[i - 1];
            acc += shift_reg[i] * C[i];
        }
    }
    * y = acc;
}
```

显然，上述的函数需要调用多次才能产生输出信号。上述代码对于构建一个基于流的架构来说很方便，因为我们可以反复调用这个函数很多次来使得更多的数据输出可用。可以发现滤波器的系数是对称的，可以在很多的FIR滤波器中发现这种对称性。我们可以使用这种对称性来减少c数组的存储空间。

typedef的使用虽然是非必要的，但是对于改变数据类型来说很方便。在后面我们将会提到，这种方式对于位操作来说非常的简便。

这种流式函数结构，每次接收样本中的一个值，返回一个输出信号的值。由于阶数为11，因此我们需要存储前10个数据。

上面的实现没有提供任何对FIR滤波器实现更为有效的因素。这是一个高度顺序执行的，以及大量不必要的控制逻辑的代码。

# 计算性能

一些比较常见的性能衡量的单位包括：运算速度为X bits/second；或者执行Y operations/sec。还有就是乘累加操作：MACs/second。


