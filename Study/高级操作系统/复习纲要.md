# 名词解释

## 写时拷贝

写时拷贝是在需要写入的时候才进行资源复制，是一种可以推迟甚至免除拷贝数据的技术。如Linux的fork()函数使用了写时拷贝数据的实现，创建子进程的时候不需要立即复制数据，父子进程以只读的方式共享没有修改的数据空间。当父子进程之一修改数据时才进行拷贝。

## 内核抢占

内核抢占是指，当进程位于内核空间，此时有一个更高优先级的任务出现时，将当前任务挂起，切换去执行更高优先级的任务，这种强制挂起的动作就是**抢占**，可抢占的前提必须要保证进程重新调度是安全的，即当前的任务没有锁。在这种情况下内核可以在任何时间抢占正在进行的任务。2.6版本后的Linux内核是可抢占的，具有上述允许内核执行更高优先级任务的能力。

## 延时写

进程往磁盘中写数据时，先往高速缓存中写，以便随后读取它时，能够直接从高速缓存中读，而不必启用磁盘读取。Linux采用延迟写的策略，也就是说：如果缓冲区还没写满，则不着急把数据写入到磁盘上，而是在缓冲区管理的数据结构中对该缓冲区行设置标志，以便在高速缓存中的数据延迟到必须写入到磁盘的时候才进行写盘操作。

## 系统调用

系统调用时内核为应用程序提供的访问硬件设备和其他操作系统资源的一组抽象接口。系统调用是用户空间访问内核的唯一手段，除异常以及陷入以外，它是内核唯一的合法入口。

## *内核模块*

模块就是一个已编译但是未链接的可执行文件。Linux是一个一体化的内核，内核中各个部件之间联系紧密，运行效率高。但是为了避免扩展时用户必须重新编译整个内核，Linux使用了模块机制。从内核的角度上来看，模块是运行时可链接、可删除的，至少包含两个函数的代码段。这个代码段一旦被链接到内核，它就是内核的一部分，称为内核模块。从用户的角度上来看，模块是内核外挂的配件，需要时将其链接到内核，不需要时将其删除，它为用户提供了一种扩充内核功能的手段。

## 内核线程

内核线程：独立运行在内核地址空间的进程，可以被调度，可以被抢占，但是没有独立的地址空间，只能运行在内核地址空间，负责完成内核在后台执行操作的任务，只能由其他内核线程创建。

## current宏

current宏是一个全局指针，指向当前进程的struct task_struct结构体，即表示当前进程。

## *proc文件系统*

Linux系统上的/proc目录是一个文件系统，是一种伪文件系统。是内核以及内核模块用来向进程发送信息的机制，让你可以和内核内部的数据结构进行交互，获取有关进程的相关信息，在运行时改变设置（修改内核参数）。与其他文件系统不同，proc文件系统运行在内存之中而不是在磁盘上。proc文件系统可以被用于搜集系统以及运行中内核的信息。

## 原子变量

原子变量是原子操作的基本单位，提供了一种原子的、不可中断的操作。

## *单内核*

单内核就是把一个内核整体作为一个大的过程来实现，同时运行在一个大的单独的地址空间。所有的内核服务都在一个大的内核空间中运行，内核可以直接调用函数。Linux是一个单内核，运行在单独的地址空间，单内核具有简单和高性能的特点。

## 进程时间片

进程在被抢占前所能运行的CPU时间，是一个有系统调度策略所设定的数值。Linux采用了预加载调度策略，每个进程只运行很短的时间：200ms。Linux还会根据进程的优先级动态调整分配给进程的时间片，保证高优先级的进程执行的高频率和长时间。

## 上下文切换

从一个可执行的进程切换到另一个可执行的进程，由context_switch()来完成。执行了两项基本工作：把虚拟内存从上一个进程的映射切换到新进程当中；从上一个进程的处理器状态切换到新进程的处理器状态当中，包括恢复与保存堆栈信息以及寄存器信息。

- switch_mm()，把虚拟内存从上一个进程映射切换到新进程；
- switch_to()，从上一个进程的处理器状态切换到新进程处理器状态中；

## 中断机制

硬件处理IO机制的时候，内核可以处理其他任务而不是等待硬件完成，直到硬件完成了请求的操作后，再通知内核回头处理，这就是中断的机制。

## *触发软中断*

一个注册的软中断必须被标记后才会执行，这被称作触发软中断（raising the softirq）。

## 临界区（critical region）

访问和操作共享数据的代码段。整个临界区是一个不可分割的指令。

## *同步*

避免不安全的并发和防止竞争条件被称为同步（Sysnchronization）。

## 死锁

有一个或多个线程和一个或多个资源，所有的进程都在等待其中一个资源，但是所有的资源都被占用了，所有的线程都在互相等待，但是它们永远不会放弃已经占有的资源，任何线程都无法继续，这就发生了死锁。

## 竞争条件

多个进程或者线程在读写一个共享数据的时候依赖于它们执行的相对时间，这种情形叫做竞争。这样的多个进程或者线程可能处在同一个临界区当中，竞争条件就发生在这多个进程或线程在读写数据时，其最终的结果依赖于多个进程指令的执行顺序。

## 争用

锁的争用，是指当锁正在被占用的时候，其他线程试图获取该锁。

## 自旋锁

Linux内核最常见的锁。一个执行线程想要访问被自旋锁保护的共享资源，必须先得到锁，自旋锁最多只能由一个线程持有。锁的持有者在访问完毕后必须释放锁。当执行线程访问的共享资源没有其他线程保持锁时，该线程立刻获得该锁，否则线程就会保持“忙循环”——“旋转”——“等待锁重新可用”的自旋锁，只有自旋锁的保持者释放锁，这样请求自旋锁的执行线程就能立刻获得它。

## 屏障

支持乱序发射指令的处理器中，可以是处理器所执行的指令集中提供的一条机器指令，该指令之后的指令必须要在之前的指令全部提交之后才能发射执行。也可以指编译器不要给该指令周围的指令序列重排序。

## 文件系统

文件系统是特殊的数据分层结构，包括文件、目录以及相关的控制信息，负责存储和管理文件信息，文件系统的通用操作包括：创建、删除和安装等等。

VFS：内核子系统，为用户空间的程序提供了文件系统相关的接口。系统中所有的文件系统依赖于VFS共存，也依赖于VFS协同工作。

## 软实时

内核调度进程，尽力在它限定的时间来到前运行，但不能保证总能满足这些进程的需求。

## *索引节点*

一个索引节点代表文件系统中的一个文件（虽然只有在被访问的时候才会创建），也可以是管道或者设备这样特殊的文件。

## 进程

处于执行期的程序和它所包含的资源的总称。资源包括：打开的文件、挂起的信号、内核内部数据、处理器状态等等。

## 线程

进程中活动的对象，为共享地址空间的程序提供多个执行线索，共享打开的文件和其他资源。线程是内核调度的对象，Linux中线程和进程没有区别，线程有独立的程序计数器、进程栈和一组进程寄存器，以及唯一的隶属于线程的task_struct。

## 内核线程

标准的进程，只存在于内核空间，没有地址空间，只能由其他内核线程创建，可以被调度、抢占。

## Thread_info

内核栈底的数据结构，有一个指针指向task_struct。2.6之前task_struct直接放在栈底。

## 进程家族树

所有进程都是1号进程init的子孙。进程只能有一个父母，在task_struct中用parent表示。进程可以有0个以上的子女，在task_struct中用children表示。

## *Linux调度实现四个主要部分*

时间记账、进程选择、调度器入口、睡眠和唤醒。

## *运行队列*

给定处理器上可执行的进程的链表，在对运行队列操作前要先将它锁住。运行队列中的数据：用于解决并发问题的锁，指向当前任务和空任务的指针，优先级数组，统计信息。

## 优先级数组

两个优先级矩阵：活跃的和过期的矩阵。一个进程用完时间片会重新计算并放进过期队列中。实际进程队列为空就交换。

## 睡眠和唤醒

睡眠：置标志为睡眠，将自己放入等待队列，把自己从运行队列中删除，调用schedule()选择新的进程运行。

唤醒：置标志为可运行，从等待队列中删除，加入到运行队列后面。

## 优先级和时间片的计算

动态优先级用于计算优先级：nice值+进程交互性的奖励或罚分（bouns）；为了确定一个进程是否是交互性的，Linux记录一个进程用于休眠和用于执行的时间（0 - MAX_SLEEP_AVG），当进程从休眠恢复到执行时，增加；运行一段时间后减少。

静态优先级用于计算时间片：进程创建时，子进程和父进程会均分时间片；任务的时间片用完时，基于任务的静态优先级重新计算时间片。

## *与调度相关的系统调用*

- 调度策略和优先级相关的系统调用；
- 处理器绑定系统调用；
- 放弃处理器时间。

## *调度器运行的时机*

- 进程阻塞在IO操作上；
- 硬件中断；
- 时间片到；
- 内核主动调用调度器；

## CFS

- 任务的运行时间=调度周期*进程权重/所有任务权重之和，权重和nice值由一一对应的关系。
- vruntime=实际运行时间*NICE_0_LOAD/进程权重，系统定时器周期修改。

进程的vruntime宏观上同时推进，调度选择vruntime最小的，所有就绪任务根据vruntime组织成红黑树。

## 用户空间间接执行系统调用

由于不允许用户直接访问内核代码，应用必须要通知内核其想调用系统调用，使系统切换到内核。这一通知内核的机制使一个软中断：产生一个异常，系统切换到内核模式，执行异常处理程序即系统调用处理程序。

x86上，定义软中断是函数system_call()；

x86处理器增加了一个特性sysenter。应用把系统调用号传递到内核空间，x86中使用eax寄存器。system_call()检查调用号，如合法就调用指定的系统调用。

## 参数验证

系统调用必须保证其所有的参数是合法的，例如：

- 指针指向的内存区域属于用户空间且在进程的地址空间里；
- 如果是读/写/执行，那么该内存应该标记为可读/写/执行；

两种方法完成必须的检查和内核空间与用户空间之间的数据拷贝：

- 向用户空间写：copy_to_user()；
- 从用户空间读：copy_from_user();
- 读写权限检查：suser()和capable();

## 绑定一个系统调用的步骤

在系统调用表最后加入一个表项 - 对于每一种支持的体系结构，系统调用号定义在<asm/unistd.h> - 编译进内核映像。

## 从用户空间访问系统调用

直接访问系统调用：设置寄存器值，执行trap。_syscalln()，其中n=0~6。

## 软中断

- kernel/softirq.c定义了一个32个元素的结构数组；
- 登记的softirq的最大数目不能改变；
- 工作时允许被中断服务程序抢占（其他softirq不行）；
- 可并行
- 软中断要在do_softirq()中执行；
- 引入软中断主要是为了可扩展性；
- 注册处理程序：open_soft(irq)
- 触发软中断：raise_softirq()
- 返回指定CPU上未处理的软中断：softirq_pending(CPU)

## *软中断的执行*

- 中断处理程序在返回前触发它的软中断，使其稍后执行；
- 检查和执行待处理的软中断的时机：
  - 中断处理结束时；
  - 内核线程ksoftirq在系统空闲时；
  - 内核代码中调用do_softirq函数时。
- 使用软中断：时间要求最严格的下半部：网络和SCSI设备

## 工作队列

工作队里使用内核线程来执行**驱动**中需延迟执行的工作。所有的工作线程都是普通内核线程，使用worker_thread()作为线程函数。该线程函数在进行一段初始化操作后便进入无限循环，并睡眠等待；当由需要处理的延迟工作被加入到工作队列中时，该线程函数被唤醒并循环处理对应工作队列中每一个工作单元；

驱动为需要延迟处理的工作建立一work_struct结构，该结构即为工作单元。

## 可扩充性

系统可被扩展的程度，考虑大量的进程，处理器以及内存。

## 安全代码

在中断处理程序中能避免并发访问的安全代码称作安全代码。

## 原子操作与非原子操作

非原子操作`__test_bit()`，原子操作`_test_bit()`，非原子操作执行的比原子操作快。

## 信号量

- down_interruptible()试图获得信号量，如果不可用就设为TASK_INTERRUPTIBLE并进入睡眠；
- down_trylock()通过阻塞的方式试图获取信号量。

## 自旋锁

- 任何时候只能由一个进程持有自旋锁；
- 自旋锁不可递归；
- 忙等待；
- 长时间占有自旋锁不明智；
- 用于中断处理程序时：禁用本地中断，否则可能会试图两次获得自旋锁。

## 禁止抢占

内核可抢占，被抢占的进程可能处于临界区；

解决方法：适用自旋锁作为非抢占区的标记。

## 物理页

- MMU内存管理单元，把虚拟地址转换为物理地址。以页为单位来管理物理内存，32位4k，64位8k。
- 每个物理页由一个struct page
  - flags
  - count，使用page_count()访问
  - virtual

## 区

Linux分为6个区，主要用到4个区：

- ZONE_DMA：包含的页能用来执行DMA操作；
- ZONE_DMA32：只能被32位设备访问；
- ZONE_NORMAL：能正常映射的页；
- ZONE_HIGHEM：包含“高端内存”，其中页不能永久的映射到内核地址空间。

## gfp_mask标志

分为三类：

1. 行为修饰符：内核应当如何分配所需的内存；
2. 区修饰符：从哪个区分配内存；
3. 类型标志：前2者的组合。

## Slab分配器

一种策略，用于缓存内核对象。

Object：经常适用的数据结构，例如inode；

Cache：存储某种类型的对象；

Slab：包含由缓存的对象。

每种对象类型有一个Cache，cache包含有一个或者多个slab，slab可能会占有一个或者多个连续的内存页。

三种状态：Full、Partial和Empty。

## Slab分配算法

1. 为特定的类型对象选择适合的Cache；减少内部碎片
2. 从cache中第一个部分满的slab分配对象；减少页的分配和释放
3. 没有部分满的slab就从空的slab中分配；
4. 如果没有空的slab，就分配新的slab。

## VFS主要数据结构

打开文件对象：一个打开文件的相关信息；

dentry：关于目录项的相关信息，名字+inode号；

inode：文件或者目录唯一的描述符，包含权限、时间信息和存放地址，inode号是一个整数

超级块：描述一个已安装的文件系统

文件系统类型：文件系统的实现模块、一组实现的函数以及相关的链表。

## 文件对象

1. struct file
   - 关联文件和进程
   - 磁盘上没有相关的结构
   - 打开文件时创建
2. 文件描述符（small ints）
   - task_struct结构中的一个数组的索引

## Dentry

目录项的抽象，每个dentry有一个父dentry（除了root）。

Dentry缓存：

- 提高文件系统性能；
- Dentry缓存控制着inode缓存，dentry被释放时inode才会被释放；
- Dentry缓存通过哈希表访问；
- Dentry状态：free、in-use、unused、negative。

## 虚拟内存区域

内存区域由vm_area_struct接口体描述。内存区域在Linux内核中也经常被称为虚拟内存区域。

mm_struct内存描述符，表示进程的地址空间。

## inode

一个文件或者目录唯一的描述符，包括其权限、时间和存放地址；

位于linux/fs.h

# 简答题

## task_struct作用？10个以上的成员及作用

在Linux中每个进程都有task_struct数据结构来定义，进程的所有操作都要依赖task_struct，task_struct是进程存在的唯一标志，创建进程时，系统会产生一个task_struct结构，并从父进程处继承一些数据，并把新进程插入到进程树当中。

task_struct中的一些成员和作用：

1. state: 标识进程的状态
2. flag: 进程标识
3. has_cpu: 获取的处理器
4. priority: 进程优先级
5. lock_depth: 锁深度
6. pid: 进程标识号
7. pgrp: 进程组号
8. *mm: 内存管理信息
9. *fs: 进程的可执行映像所在的文件系统
10. *files: 进程打开的文件
11. signal: 信号
12. policy: 该进程的调度策略
13. timeout: 软件定时

## VFS思想

 VFS，虚拟文件系统转换，Virtual Filesystem Switch，虚拟文件系统。

主要思想：VFS提供不同文件系统的统一接口，将文件系统相关的系统调用和具体的文件系统操作分开，操作系统通过调用VFS来操作具体文件系统的文件。

实现：通用文件模型（common file model），核心是四个对象类型：超级块对象（superblock object）、索引节点对象（inode object）、文件对象（file object）以及目录项对象（dentry object）。这四个对象都是内核中的数据结构，是VFS的核心。无论哪种文件系统其在内存中的映像都要和通用文件模型打交道。

在Linux下，通过VFS，一个抽象的通用访问接口屏蔽了底层文件系统和物理介质的差异性，每一种文件系统都隐藏了底层代码实现的细节。因此，对于VFS层以及其他的内核模块而言，所有的文件系统看起来都是一样的，因此可以支持多种文件系统。Linux中的VFS采用的是面向对象的编程方法。

## 在进程控制处理模块方面，linux和unix的实现区别是什么？为什么会产生这种区别？

1. Unix的进程控制块分为两个部分，基本块proc以及扩充控制块user。proc中存放着一个进程最基本的信息，需要常驻内存。user块中存放着只有运行时才需要的数据以及状态信息，因此为了节省内存空间，当进程暂时没有在运行时，会存放在磁盘上的交换区当中。user块总是和进程的数据段一起换入换出内存的。
2. Unix中有线程的概念，而Linux中并没有线程的概念，线程被视为与其他进程共享资源的进程。
3. 进程创建的写时拷贝（Linux）。避免大量的拷贝。
4. Linux通过slab分配器动态分配task_struct，这样能达到对象复用和缓存着色的目的，通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。task_struct中完整包含有一个正在执行的进程的数据：进程状态、打开的文件、地址空间、信号等等。
5. 造成的主要区别的原因是，早期的Unix机器的内存小，分部处理更加节省空间；而后随着技术进步内存容量得到提升，Linux的处理方式更为高效快速。早期Unix的fork()实现简单且效率低下，Linux做出了改进。

## 进程和线程的区别是什么？Linux是如何实现线程的？

1. 进程是处于执行期的程序和它所包含的资源的总称，线程是进程中的活动对象。
2. 进程是资源管理的最小单位，同一个进程中的所有线程共享资源。
3. 进程至少有一个线程，进程拥有独立的地址空间而线程没有。
4. 线程是程序执行的最小单位，内核调度的对象是线程而不是进程。
5. 采用线程是为了更好的支持SMP（Symmetric Multi-Processor，对称多处理器架构）以及减少上下文切换的开销。线程上下文切换的开销比进程小多了。将同一个进程中的多个线程分配到不同的CPU上执行，在SMP中可以多个CPU执行各个线程，达到最大程度的并行性。

Linux线程的实现：内核把所有的线程都当做进程来实现，线程为视为只与其他进程共享资源的进程。每个线程拥有独立的程序计数器、进程栈和一组进程寄存器，并且拥有唯一的隶属于线程的task_struct。

## Linux进程的状态有哪些？

1. 运行状态（TASK_RUNNING），进程正在被CPU执行，或者准备就绪可由调度程序调度执行。
2. 可中断睡眠状态（TASK_INTERRUPTIBLE），系统不会调度该进程运行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到了一个信号，都可以唤醒进程转换到运行状态。
3. 不可中断睡眠状态（TASK_UNINTERRUPTIBLE），只有明确使用wake_up()函数才能唤醒转换到运行状态。
4. 跟踪状态（TASK_TRACED），可被其他进程跟踪。
5. 暂停状态（TASK_STOPPED），收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时进入该状态。
6. 僵死状态（TASK_ZOMBIE），进程停止运行，但父进程未询问其状态。
7. 退出状态（TASK_DEAD），即将被销毁。

## 内核的锁的实现方式有哪些？内核只要一个锁就能锁定数据结构，为什么还实现多种方式的锁？

五种锁：原子操作、自旋锁、信号量、BKL（大内核锁）、seq锁（顺序锁）

锁的上下文环境不同、加锁的时间不同、维护锁的开销不同，因此要实现多种锁来应对不同的情况。

1. 原子操作保证指令的执行序列不会被打断，不会被线程调度机制打断。
2. 自旋锁快速简单，适用于加锁时间不长的情形，并且代码不会睡眠。请求锁的进程会不断自选（不会睡眠）。不允许递归
3. 信号量是睡眠锁，适用于加锁时间长并且允许睡眠的情况。
4. BKL锁允许递归，不会出现死锁，但是使用比较少并且有害。
5. seq锁适用于读写共享数据，轻量级，对写者有利，读者循环等待。适用场合：很多读者，写者很少，写优先于读，数据简单。

## 举例说明内核的某一块设计是利用面向对象技术的

面向对象三个基本特征：封装、继承和多态。封装就是把方法和属性封装起来，实现信息的屏蔽和抽象。继承就是一个对象直接使用另一个对象的属性和方法。多态就是接口有多种不同的实现方式。Linux中多种技术都体现了OO的思想：

1. 文件系统的file对象，file对象只提供了原型而没有提供具体的实现，具体的实现由具体的文件系统提供。内核中重要的数据结构都进行了封装，如文件系统中的inode对象，内存管理中的page对象、cache对象和slab对象等等。
2. 内核中的通用链表结构可以看做是一个基类，基本操作包括节点的插入、删除、初始化和移动，其他的数据结构可以视为它的子类。如果要组织成双向链表，可以包含这个通用链表的对象。内核中使用通用链表的数据结构非常多，包括进程调度、存储器管理、文件系统和网络协议等等。
3. 虚拟文件系统VFS体现了多态性。VFS可以看做是抽象基类，具体的文件系统ext2、VFAT可以看做是它的子类，VFS提供的操作是一个纯虚函数的概念，具体实现由具体的文件系统提供。

## *内核开发的特点*

1. 不能访问C库，C库对于内核来说太大了，但是常用的C库函数在内核中都有实现。
2. 必须使用GNU C。
3. 缺乏内存保护机制，内核中的内存不分页。
4. 浮点数很难使用，原则是在内核中不使用。
5. 只有容积很小并且定长的堆栈。
6. 支持异步中断、抢占和SMP，容易出现竞争条件，时刻注意同步和并发，设置同步机制保证不出现竞争条件，使用自旋锁和信号量解决竞争条件。
7. 要注重可移植性。

## 什么是中断上下文，什么是进程上下文，他们之前的区别、联系？中断是否一定要在中断上下文中？

中断上下文：执行一个中断处理程序或者下半部时，内核处于中断上下文。硬件通过触发信号，导致内核进入中断处理程序，硬件的一些变量和参数会传递给内核，内核根据这些参数进行处理。“中断上下文”可以指硬传递过来的变量和参数以及内核需要保存的一些其他环境。是一个内核控制路径，代表了中断发生时正在运行的进程执行，比一个进程要“轻”。

进程上下文：用户空间的进程通过系统调用进入内核空间，需要传递很多的参数和变量给内核，内核也要保存用户进程的一些寄存器值、变量号。“进程上下文”可以指用户进程传递给内核的参数和变量以及内核要保存的那些变量、寄存器值以及环境。系统提供给进程处于动态变化的运行环境总和，包括CPU所有寄存器中的值、进程状态以及堆栈中的内容。陷入内核空间后，内核代表进程执行并处于进程上下文。在进程上下文中，内核可以被休眠也可以被抢占。

中断上下文没有对应的进程，不可睡眠/阻塞，有一个独立的栈。而进程上下文与一个进程相关，可以睡眠和调用调度器。两者之间没有瓜葛。当执行一个中断服务程序或下半部时，内核一定要在中断上下文中。

## Linux如何实现O(1)调度以及CFS

Linux调度主要在一个运行队列（runqueue）中操作，运行队列中有两个优先级数组（prio_array），定义如下：

```C
struct prio_array
{
    int nr_active; // 任务数目
    unsigned long bitmap[BITMAP_SIZE]; // 优先级位图
    struct list_head queue[MAX_PRIO]; // 优先级队列
}
```

两个数组一个挂着过期的时间片用完的task，另一个挂着活跃的时间片未用完的task。

过程可以参照https://zhuanlan.zhihu.com/p/33461281, https://blog.csdn.net/fangjian1204/article/details/39736725, https://www.ibm.com/developerworks/cn/linux/l-cfs/index.html#artrelatedtopics.

## 系统调用和C库函数的作用，两者的区别？

系统调用的作用：在用户空间和硬件设备之间添加了一个中间层，作用：

1. 为用户空间提供了一种硬件的抽象接口；
2. 保证了系统的稳定和安全；
3. 方便实现多任务和虚拟内存；
4. 系统调用是用户空间进入内核的唯一手段。

C库函数的作用：C库实现了系统主要的API，包括标准C库函数和系统调用。用户只要和库函数打交道就可以使用系统调用访问系统资源。

两者的区别：

1. 系统调用是操作系统的一部分，库函数是语言和应用程序的一部分；
2. 系统调用通常提供一种最小界面，库函数通常提供比较复杂的功能；
3. 系统调用不能被替换，但库函数可以；
4. 应用程序可以调用库函数和系统调用，很多库函数则会调用系统调用，但库函数不是内核的入口点。

## 为什么分上下半部，上半部和下半部的含义是什么？下半部的处理方式有哪些？简述tasklet的思想。

划分上下半部的原因：中断服务程序异步执行，可能会中断其他的重要代码，包括其他中断服务程序。为了避免被中断代码延迟太长的时间，中断服务程序必须尽快进行。所以中断程序只做必要的工作，而把其他的工作推迟到之后进行。Linux中将中断处理划分为两个部分，上半部和下半部。

上半部：中断处理程序，他所要完成的工作越少越好，执行的越快越好。因此只包含一些硬件相关、对时间敏感、保证不能被中断打断的任务。

下半部：剩下的与中断有相关性但是可以被延后处理的任务，比如一些相关数据的操作处理。下半部分延后执行处理且可以响应所有的中断。将系统分为上下半部分可以使得系统处于中断屏蔽的状态的时间尽可能的短，提高系统的响应能力。

实现下半部的方法有很多，使用最多：软中断、tasklet和工作队列。

Tasklet的实现基础是软中断，与软中断的行为很相似。Tasklet内部对软中断实现了封装，外部接口更简单，锁保护的要求更低。Tasklet具有以下的特性：

1. 一种特定类型的tasklet只能运行在一个CPU上，不能并行只能串行；
2. 不同类型的tasklet可以并行运行在多个CPU上；
3. 软中断是静态分配的，内核编译后就不能改变，而tasklet灵活许多，可以在运行时改变。

tasklet是在两种软中断的类型基础上实现的（HI_SOFTIRQ和TASKLET_SOFTIRQ），由于其特殊的规则，降低了驱动程序开发者的负担。如果不需要软中断的并行性，那么tasklet是最好的选择。

注：软中断作为下半部的机制是伴随着SMP应运而生的。它使得对时间不敏感的任务可以延后执行，并且可以在多个CPU上同时执行：软中断在产生后不会立刻执行，必须等待内核的调度才能执行，软中断不能被自己打断，只能被硬件中断打断，唯一能抢占软中断的是上半部；可以并发运行在多个CPU上，软中断必须实现可重入的函数，并且需要使用自旋锁来保护。只有网络/SCSI（**S**mall **C**omputer **S**ystem **I**nterface， 小型计算机系统接口）直接使用软中断——运行频率很高、连续性要求很高、高效完成加锁工作。

## 内核同步方法，为什么要分这几种方法

1. 原子操作：原子的，执行过程中不能被打断的操作，这种操作从一开始执行到最后，中间都不会切换到其他进程；
2. 自旋锁：实现保护共享资源，防止多处理器并发提出的机制。一个执行单位想要获得自旋锁保护的资源必须先得到锁，否则将自旋到得到锁；
3. 信号量：睡眠锁。没有获得信号量的任务进入队列进行睡眠，直到信号量被释放后才被唤醒；在多线程环境下保护关键的代码段不被并行调用。进入一个关键的代码段线程必须获取信号量，执行完成后必须释放信号量；
4. 完成变量：若在内核中的一个任务需要发出信号通知另一个任务发生了某个特定的事件，则使用完成变量。完成变量唤醒在完成变量上等待的任务；
5. BKL：基于小等待自旋锁，全局自旋锁，一个进程可以多次请求BKL（可以递归），保证一个进程只能取得一次锁。在释放前任何锁定的动作都不会导致实质上再次锁定，防止死锁。BKL多用于保护代码而不是数据。

多种内核同步的方法，适用于各种不同的场景。

## 1号进程的作用

1号进程就是pid为1的进程，是用户空间第一个被创建的进程，也称为init进程。它完成一系列进程的创建工作，这些进程都是init进程的子孙进程。其在一个死循环中等待这些子进程的退出事件，并调用waitid系统调用来完成“收尸”的工作（清理僵尸进程）。init进程不能被暂停，也不能被杀死。init进程等待进程退出时处于TASK_INTERRUPTIBLE状态，清理僵尸进程时处于TASK_RUNNING状态。

## Linux操作系统实现的是用户级线程还是核心级线程？如何实现？

核心级线程。线程当做进程来实现，与其他进程共享地址空间的进程。拥有独立的程序计数器、进程栈和一组进程寄存器以及一个唯一的隶属于线程的task_struct。

## Open()系统调用做了什么事情

进程要访问一个文件，首先要获取一个文件描述符，通过open系统调用获取这个文件描述符。文件描述符是有限的资源，不用的时候应该释放。该系统调用用来获得欲访问文件的文件描述符，如果文件不存在，则还可以用来创建一个新文件。其函数为sys_open()。

## 操作系统调度的衡量？桌面型和服务器型操作系统各自要强调的地方？

主要指标：吞吐量、响应时间、周转时间、等待时间、cpu利用率和公平性等。

1. 吞吐量：单位时间内CPU完成的作业的数目；
2. 响应时间：作业从提交到系统作出响应做需要的时间；
3. 周转时间：作业从提交到完成所经过的时间，包括等待时间、在就绪队列中排队、在处理器上运行以及进行IO操作的总和；
4. 等待时间：作业在就绪队列中等待的时间；
5. cpu利用率。
6. 公平性：确保每个用户可以获得合理的CPU份额以及其他资源份额，不会使某个进程出现饥饿的状况。

桌面级操作系统的进程一般是IO消耗型的，大部分时间花在提交IO请求和等待IO请求上，不需要长时间片，更强调**响应时间**。而服务器型操作系统一般是CPU消耗型的，大部分之间都花在执行代码上，除非被抢占，否则会不停的运行。需要长时间片，强调的是**吞吐量**。

## Linux伙伴算法是干嘛的？怎么实现？

Linux内核通过伙伴算法来管理物理内存。伙伴系统（Buddy System）理论上是非常简单的内存分配算法。用途：尽可能减少外部碎片，同时允许快速回收和分配物理页面。

实现原理：把所有的页面组织成11个块组，每个组中块的大小为$2^{页面数量}$个页面。第0组：1个页面大小；第2组：4个页面大小。每一组中块的大小是相同的，相同大小的块组织成一个链表。算法工作原理就是从小的块往大的块进行适配，大块适配后会将块剩余的空间插入到小块的链表中。如果没有适合的空闲块就会报错。而块释放的过程就是上述的逆过程，如果有两个块满足：大小相同且物理地址连续，则两个块会合并为一个块插入到大块的链表中，这个过程会不断的迭代。

## 简述Linux内核的特点

Linux是单内核，但汲取了微内核的精华：

1. 动态加载内核模块，可以动态卸除和加载内核代码；
2. 支持对称多处理机制（SMP）；
3. 内核可抢占，内核可以运行更高优先级的任务；
4. 独特的线程实现，不区分线程和进程，都是task；
5. 设备管理提供了具有设备类的面向对象的设备模型、热插拔事件以及用户空间的设备文件系统；
6. 抛弃了Unix中拙劣的stream特性，忽略了一些实际上不会使用的过时的标准；
7. 自由，公开开发模型自由务实发展。

## Linux2.6所实现的调度程序锁实现的目标是什么？

有效性：尽可能完成多的工作；交互性：尽快响应用户；公平性：不允许任何进程饥饿。

1. 充分实现O(1)调度，不管进程数量如何，调度程序使用的算法都能够在恒定的时间内完成。
2. 全面实现了SMP的可扩展性，每个处理器拥有自己的锁和自己的可执行队列。
3. 强化SMP的亲和力，尽量将相关的一组任务分配给同一个CPU执行。
4. 加强交互性能。即使系统处在相当负载的情况下，也能保证系统的响应，立即调度交互式进程。
5. 保证公平。在合理设定的时间范围内，没有进程会饥饿，也没有进程不公平的得到大量的时间片。

## 进程创建的步骤

Linux创建进程大体分为两个步骤：

1. fork()函数负责拷贝当前进程创建一个子进程。
2. exec()函数负责读取可执行文件装入到地址空间中执行。

Linux通过clone()系统调用实现了fork()，clone()调用了do_fork()，do_fork()调用copy_process()。

vfork()和fork()的区别：vfork不拷贝父进程的页表，且创建完成后父进程阻塞，直至子进程结束或者执行exec()。

## 负载平衡程序的操作步骤

Linux为SMP中的每个处理器都准备了单独的可执行队列和锁，而负载平衡程序负责保证这些可执行队列的负载处于平衡状态。负载平衡程序有load_balance()函数实现：

1. 找出最繁忙的可执行队列；
2. 从最繁忙的队列中选择一个优先级数组（过期的优先）以便进行抽取；
3. 选择含有进程的优先级最高的链表；
4. 从链表中选择不在运行并且不在高速缓冲区，可移动的进程抽取；
5. 重复上述步骤直到平衡。

## 用户抢占发生在什么情况？

内核即将返回用户空间的时候，如果need_resched标志被设置，那么就会调用schedule()，此时就会发生用户抢占，因此用户抢占发生在一下两种情况：

1. 从系统调用返回用户空间；
2. 从中断处理程序返回用户空间。

## 内核抢占发生在什么情况？

1. 中断处理程序正在执行，返回内核空间之前；
2. 内核代码再一次变得可抢占（preemt_count为0）；
3. 内核中的任务显示调用schedule()；
4. 内核中的任务阻塞时；

## 请简述SCHED_FIFO与SCHED_RR实时调度的区别

SCHED_FIFO是一种简单的先入先出的调度算法，没有时间片。所有SCHED_FIFO级的进程都比SHCED_NORMAL级的进程都先得到调度。由于SCHED_FIFO不基于时间片，因此只要处于可执行状态，它就会一直执行下去，除非自己阻塞或者主动放弃CPU。只有较高级的SCHED_FIFO或者SCHED_RR进程才能抢占SCHED_FIFO任务。

SCHED_RR与SCHED_FIFO大致相同，但是SCHED_RR受到时间片的限制，在耗尽分配的时间片后就不再接着执行了。也就是一种实时轮转调度的算法。带时间片的SCHED_FIFO。

## 系统调用作为进程与硬件之间的一个中间层所起的作用有哪些？

1. 为用户空间提供了一个硬件的抽象接口；
2. 保证了系统的稳定和安全；
3. 是用户空间进入内核的唯一手段，除了异常和陷入以外的唯一入口。

## 造成并发执行的原因有哪些？

1. 中断：中断可以在任何时刻发生，随时打断当前执行的代码；
2. 软中断和tasklet：内核可能在任何时刻唤醒或者调度软中断和tasklet，打断当前的任务；
3. 内核抢占：内核具有抢占性，在内核中的任务可能会被其他任务抢占；
4. 睡眠以及用户空间的同步：在内核执行的进程可能会睡眠，会唤醒调度程序调度新的一个进程运行；
5. SMP：两个或者多个处理器同时执行代码。

## 请简述在分配内存中，如何选择内存分配函数。

alloc_pages、kmalloc、vmalloc、slab

1. 需要连续的物理页，使用kmalloc()或者低级分配器，常用的内核默认分配方式；字节为单位。
2. 想要从高端的内存进行分配，使用alloc_pages()。
3. 仅仅需要虚拟内存上连续的页，使用vmalloc()。
4. 创建和销毁很大的数据结构，考虑建立slab高速缓存。

## 简述硬链接和软链接之间的区别

Unix下每个文件都有一个相关的数据结构来表述该文件相关的信息，称为inode。创建硬链接就是创建一个inode的指针，不会占用磁盘空间。硬链接上有计数，当计数为0时，文件将会被删除。硬链接有一些限制：不能创建目录的硬链接，防止循环；不能夸文件系统或者分区创建硬链接。

软链接也叫符号链接，本身是一个独立的较小文件，指向新创建的inode，是文件另一个路径的别名。软链接的创建没有限制，但是可能会出现循环的情况。

## 请简述find_vma()、find_vma_prev()以及fine_vma_intersection()之间的区别

find_vma()函数在指定的地址空间中搜索第一个vm_end大于addr的内存区域，也就是找到第一个包含或者大于addr的内存区域，如果没有找到就返回null，否则返回指向匹配的内存区域的vm_area_struct结构体指针。find_vma_prev()则是返回第一个小于addr的内存区域。

fine_vma_intersection()返回第一个和指定地址区间相交的VMA。

## 如何创建地址空间？

用户空间通过mmap()调用内核函数do_mmap()的功能，创建一个新的线性地址空间，如果创建的地址空间和一个已经存在的地址空间相邻，并且拥有相同的访问权限就可以合并。如果不能合并就要创建一个新的VMA了。无论如何，do_mmap()都会将一个地址区间加入到进程的地址空间中。

## 如何删除地址空间？

系统调用munmap()提供了一种从自身地址空间中删除指定地址区间的方法，里面封装了do_munmap()。从指特定的进程地址空间中删除置顶的地址空间。

## 信号量与自旋锁的区别？

信号量：睡眠锁，适用于长时间持有；

自旋锁：忙等待，适用于短时间占有的锁；

## 进程的终结

释放所有物理页面、关闭所有打开的文件以及清楚task[]数组中的相关项。子进程通过系统调用exit()完成前两项，进入僵死状态，然后通知父进程通过调用waitpit()完成最后一项。

结束的起因：进程结束其工作，或者收到一个信号，或者发生了它自己不能处理的异常。

结束的过程：进程开始执行exit()函数：释放进程的地址空间；释放进程使用的资源；向父进程发送一个信号，并将自己的状态标示为TASK_ZOMBIE；调用调度程序，执行其他进程。

进程结束后保留的内核栈、thread_info以及task_struct由父进程调用waitpid()来来清理释放。

## 请简述下半部机制中软中断、tasklet、工作队列的优缺点以及使用场合

软中断：

- 优点：并发运行，可扩展性；
- 缺点：必须使用可重入函数，对锁要求高，复杂度高，静态分配不灵活；
- 场景：时间要求严格、频率高连续性要求高；

tasklet：

- 优点：接口简单，锁保护要求低，同类型的不能并行执行，实现简单，动态灵活性好；
- 缺点：只能串行（同一类）
- 场景：不需要扩展到多CPU的场合

工作队列：

- 缺点：开销大，牵扯到内核线程和上下文切换；
- 场景：中断延期工作运行于进程上下文，工作队列是唯一的选择。

## 调度程序状态之间的关系

TASK_RUNNING -> TASK_INTERRUPTIBLE

- _add_wait_queue()把任务加到等待队列中，状态置为TASK_INTERRUPTIBLE。调用schedule()，schedule()调用deactivate_task()从运行队列中删除任务；

TASK_INTERRUPTIBLE -> TASK_RUNNING

- 接收信号，将状态置为TASK_RUNNING，然后执行信号处理程序；
- 任务等待的时间发生了，try_to_wake_up()把任务置为TASK_RUNNING，调用active_task()把任务加到运行队列，之后调用schedule()，`__remove_wait_queue()`把任务从等待队列中删除。

## 防止死锁的方法

- 锁的顺序至关重要；
- 防止饥饿；
- 不要对同一个锁上两次锁；
- 锁的方案过于复杂容易造成死锁。

## 互斥体mutex的受限性

- 任何时刻中只有一个任务可以持有mutex，mutex计数永远为1；
- 给mutex上锁者必须负责给其再解锁；
- 递归上锁解锁不允许；
- 持有mutex的进程不可以推出；
- mutex不能再中断或者下半部中使用；
- mutex只能通过官方的api管理；