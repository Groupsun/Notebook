# Python3 面向对象编程

# 前置概览

来自Runoob以及官方文档。

Python中类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类汇总的同名方法。对象可以包含任意数量和类型的数据。

## 类定义

```python
class Classname
    <statement-1>
    .
    .
    .
    <statement-N>
```

访问类属性，可以在类实例化的对象中访问，也可以在创建一个类之后，通过类名访问其属性。

## 类对象

类对象即类实例化后的对象。类对象可以进行属性引用，属性是变量以及方法。

类对象实例化的时候，会自动调用类中的一个特殊方法：`__init__()`，也就是构造方法。如果类定义中没有自定义的`__init__()`方法，则python会调用默认的构造方法。`__init__()`方法中可以带有参数，且自定义的构造方法必然有一个`self`参数，这是类**实例方法**的共性。

### self代表类的对象

在python当中，习惯上**self**代表类的对象，而**cls**则代表类。此外，self也指代类中的实例变量。python中所有的实例变量都需要显式注明self前缀，没有注明的都是类变量。

## 实例对象

实例对象是每个实例独立的属性，实例对象包括数据属性以及方法。

*数据属性*（也可以称为实例变量）对应于C++中的“数据成员”。数据属性在python中不需要声明，类似于局部变量，其在第一次赋值时产生。实例对象只能在类方法声明中定义，且需要使用self来进行绑定，只作用于绑定的实例。在类的内部，实例变量使用`self.实例变量`的方式来进行访问，而在类的外部，则需要使用`实例名.实例变量`的方式来访问。

需要重点注意的是：**Python的实例变量不需要声明。其在第一次赋值时产生**。也就是说，如果一个实例变量在`__init__()`当中赋（初）值，则这个实例变量在任何实例初始化的时候就存在。而在其他方法中赋值的实例变量，则只有在实例执行了该方法后，才会存在。

另一类的实例属性引用称为*方法*。方法可以不太准确的表达为：“从属于”对象的函数。通过类名称引用的类声明中的函数是函数对象，而通过实例名引用的则是方法对象，这两者是不一样的：

```python
class MyClass:
    def f(self):
        return "Hello world!"


x = MyClass()
xmf = MyClass.f     # 函数对象
xf  = x.f           # 方法对象
```

## 方法对象

上述例子中，说明了立即调用一个方法并不是必须的。`x.f`是一个方法对象，它可以保存起来以后再进行调用。比如：

```python
x = MyClass()
xf = x.f
while True:
    print xf()
```

方法和函数的区别在于，调用方法的实例对象会作为函数的第一个参数传入。如上述`xf()`并没有参数传入，实际上，`x`就是作为该函数的第一个参数传入。也就是说，`x.f()`和`MyClass(x)`是一样的。

## 类变量和实例变量

类变量用于类的所有实例共享的属性和方法：

```python
class Person:
    company = "PDD LTD."
    def __init__(self, name):
        self.name = name


p1 = Person("ZWJ")
p2 = Person("LZH")
print(p1.company)
print(p2.company)
print(p1.name)
print(p2.name)
```

则输出为：

```
PDD LTD.
PDD LTD.
ZWJ
LZH
```

需要注意的是，列表和字典在声明在类对象时要小心，因为类对象是在所有实例之间共享的。声明mutable对象（列表、字典）为类对象可能会导致令人惊讶的结果。

### 补充说明

1. 数据属性会覆盖同名的方法属性。因此在设计大型的程序时最好对命名进行某些约定，比如约定方法单词首字母大写；数据属性加上独特的短字符串前缀（如'_'）；用动词来命名方法，用名词来命名属性等等。
2. 数据属性可以被方法以及一个对象的普通用户所引用。换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据——它是完全基于约定的。
3. 在方法内部引用数据属性，只能够通过`self`来引用。这个看似麻烦的规定实际上提升了方法的可读性：不会混淆实例变量和局部变量。
4. `self`不是一个关键词，只是一个习惯性的约定。你打可以使用别的词来替代，比如`this`。但是建议还是使用`self`。
5. 类属性的函数定义的文本并非一定要包含于类当中：

```python
def f1(self, a, b):
    return min(a, a+b)

class C:
    f = f1
    
    def g(self):
        return "g"
    
    h = g
```

其中`f`，`g`以及`h`都是C类的引用函数对象的属性。然而这种做法虽然合法，但是为了程序的可读性，请尽量不要这样使用。
6. 方法可以通过使用`self`参数的方法属性调用其他方法：

```python
class Bag:
    def __init__(self):
        self.data = []

    def add(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)
```

7. 每个值都是一个对象，因此具有 类 （也称为 类型），并存储为`object.__class__`。
