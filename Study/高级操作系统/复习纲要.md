# 名词解释

## 写时拷贝

写时拷贝是在需要写入的时候才进行资源复制，是一种可以推迟甚至免除拷贝数据的技术。如Linux的fork()函数使用了写时拷贝数据的实现，创建子进程的时候不需要立即复制数据，父子进程以只读的方式共享没有修改的数据空间。当父子进程之一修改数据时才进行拷贝。

## 内核抢占

内核抢占是指，当进程位于内核空间，此时有一个更高优先级的任务出现时，将当前任务挂起，切换去执行更高优先级的任务，这种强制挂起的动作就是**抢占**，可抢占的前提必须要保证进程重新调度是安全的，即当前的任务没有锁。在这种情况下内核可以在任何时间抢占正在进行的任务。2.6版本后的Linux内核是可抢占的，具有上述允许内核执行更高优先级任务的能力。

## 延时写

进程往磁盘中写数据时，先往高速缓存中写，以便随后读取它时，能够直接从高速缓存中读，而不必启用磁盘读取。Linux采用延迟写的策略，也就是说：如果缓冲区还没写满，则不着急把数据写入到磁盘上，而是在缓冲区管理的数据结构中对该缓冲区行设置标志，以便在高速缓存中的数据延迟到必须写入到磁盘的时候才进行写盘操作。

## 系统调用

系统调用时内核为应用程序提供的访问硬件设备和其他操作系统资源的一组抽象接口。系统调用是用户空间访问内核的唯一手段，除异常以及陷入以外，它是内核唯一的合法入口。

## 内核模块

模块就是一个已编译但是未链接的可执行文件。Linux是一个一体化的内核，内核中各个部件之间联系紧密，运行效率高。但是为了避免扩展时用户必须重新编译整个内核，Linux使用了模块机制。从内核的角度上来看，模块是运行时可链接、可删除的，至少包含两个函数的代码段。这个代码段一旦被链接到内核，它就是内核的一部分，称为内核模块。从用户的角度上来看，模块是内核外挂的配件，需要时将其链接到内核，不需要时将其删除，它为用户提供了一种扩充内核功能的手段。

## 内核线程

内核线程：独立运行在内核地址空间的进程，可以被调度，可以被抢占，但是没有独立的地址空间，只能运行在内核地址空间，负责完成内核在后台执行操作的任务，只能由其他内核线程创建。

## current宏

current宏是一个全局指针，指向当前进程的struct task_struct结构体，即表示当前进程。

## proc文件系统

Linux系统上的/proc目录是一个文件系统，是一种伪文件系统。是内核以及内核模块用来向进程发送信息的机制，让你可以和内核内部的数据结构进行交互，获取有关进程的相关信息，在运行时改变设置（修改内核参数）。与其他文件系统不同，proc文件系统运行在内存之中而不是在磁盘上。proc文件系统可以被用于搜集系统以及运行中内核的信息。

## 原子变量

原子变量是原子操作的基本单位，提供了一种原子的、不可中断的操作。

## 单内核

单内核就是把一个内核整体作为一个大的过程来实现，同时运行在一个大的单独的地址空间。所有的内核服务都在一个大的内核空间中运行，内核可以直接调用函数。Linux是一个单内核，运行在单独的地址空间，单内核具有简单和高性能的特点。

## 进程时间片

进程在被抢占前所能运行的CPU时间，是一个有系统调度策略所设定的数值。Linux采用了预加载调度策略，每个进程只运行很短的时间：200ms。Linux还会根据进程的优先级动态调整分配给进程的时间片，保证高优先级的进程执行的高频率和长时间。

## 上下文切换

从一个可执行的进程切换到另一个可执行的进程，由context_switch()来完成。执行了两项基本工作：把虚拟内存从上一个进程的映射切换到新进程当中；从上一个进程的处理器状态切换到新进程的处理器状态当中，包括恢复与保存堆栈信息以及寄存器信息。

## 中断机制

硬件处理IO机制的时候，内核可以处理其他任务而不是等待硬件完成，直到硬件完成了请求的操作后，再通知内核回头处理，这就是中断的机制。

## 触发软中断

一个注册的软中断必须被标记后才会执行，这被称作触发软中断（raising the softirq）。

## 临界区（critical region）

访问和操作共享数据的代码段。整个临界区是一个不可分割的指令。

## 同步

避免并发和竞争条件被称为同步（Sysnchronization）。

## 死锁

有一个或多个线程和一个或多个资源，所有的进程都在等待其中一个资源，但是所有的资源都被占用了，所有的线程都在互相等待，但是它们永远不会放弃已经占有的资源，任何线程都无法继续，这就发生了死锁。

## 竞争条件

多个进程或者线程在读写一个共享数据的时候依赖于它们执行的相对时间，这种情形叫做竞争。这样的多个进程或者线程可能处在同一个临界区当中，竞争条件就发生在这多个进程或线程在读写数据时，其最终的结果依赖于多个进程指令的执行顺序。

## 争用

锁的争用，是指当锁正在被占用的时候，其他线程试图获取该锁。

## 自旋锁

Linux内核最常见的锁。一个执行线程想要访问被自旋锁保护的共享资源，必须先得到锁，自旋锁最多只能由一个线程持有。锁的持有者在访问完毕后必须释放锁。当执行线程访问的共享资源没有其他线程保持锁时，该线程立刻获得该锁，否则线程就会保持“忙循环”——“旋转”——“等待锁重新可用”的自旋锁，只有自旋锁的保持者释放锁，这样请求自旋锁的执行线程就能立刻获得它。

## 屏障

支持乱序发射指令的处理器中，可以是处理器所执行的指令集中提供的一条机器指令，该指令之后的指令必须要在之前的指令全部提交之后才能发射执行。也可以指编译器不要给该指令周围的指令序列重排序。

## 文件系统

文件系统是特殊的数据分层结构，包括文件、目录以及相关的控制信息，负责存储和管理文件信息，文件系统的通用操作包括：创建、删除和安装等等。

VFS：内核子系统，为用户空间的程序提供了文件系统相关的接口。系统中所有的文件系统依赖于VFS共存，也依赖于VFS协同工作。

## 软实时

内核调度进程，尽力在它限定的时间来到前运行，但不能保证总能满足这些进程的需求。

## 索引节点

一个索引节点代表文件系统中的一个文件（虽然只有在被访问的时候才会创建），也可以是管道或者设备这样特殊的文件。

# 简答题

## task_struct作用？10个以上的成员及作用

在Linux中每个进程都有task_struct数据结构来定义，进程的所有操作都要依赖task_struct，task_struct是进程存在的唯一标志，创建进程时，系统会产生一个task_struct结构，并从父进程处继承一些数据，并把新进程插入到进程树当中。

task_struct中的一些成员和作用：

1. state: 标识进程的状态
2. flag: 进程标识
3. has_cpu: 获取的处理器
4. priority: 进程优先级
5. lock_depth: 锁深度
6. pid: 进程标识号
7. pgrp: 进程组号
8. *mm: 内存管理信息
9. *fs: 进程的可执行映像所在的文件系统
10. *files: 进程打开的文件
11. signal: 信号
12. policy: 该进程的调度策略
13. timeout: 软件定时

## VFS思想

 VFS，虚拟文件系统转换，Virtual Filesystem Switch，虚拟文件系统。

主要思想：VFS提供不同文件系统的统一接口，将文件系统相关的系统调用和具体的文件系统操作分开，操作系统通过调用VFS来操作具体文件系统的文件。

实现：通用文件模型（common file model），核心是四个对象类型：超级块对象（superblock object）、索引节点对象（inode object）、文件对象（file object）以及目录项对象（dentry object）。这四个对象都是内核中的数据结构，是VFS的核心。无论哪种文件系统其在内存中的映像都要和通用文件模型打交道。

在Linux下，通过VFS，一个抽象的通用访问接口屏蔽了底层文件系统和物理介质的差异性，每一种文件系统都隐藏了底层代码实现的细节。因此，对于VFS层以及其他的内核模块而言，所有的文件系统看起来都是一样的，因此可以支持多种文件系统。Linux中的VFS采用的是面向对象的编程方法。

## 在进程控制处理模块方面，linux和unix的实现区别是什么？为什么会产生这种区别？

1. Unix的进程控制块分为两个部分，基本块proc以及扩充控制块user。proc中存放着一个进程最基本的信息，需要常驻内存。user块中存放着只有运行时才需要的数据以及状态信息，因此为了节省内存空间，当进程暂时没有在运行时，会存放在磁盘上的交换区当中。user块总是和进程的数据段一起换入换出内存的。
2. Unix中有线程的概念，而Linux中并没有线程的概念，线程被视为与其他进程共享资源的进程。
3. 进程创建的写时拷贝（Linux）。避免大量的拷贝。
4. Linux通过slab分配器动态分配task_struct，通过预先分配和重复使用task_struct，可以避免动态分配和释放所带来的资源消耗。task_struct中完整包含有一个正在执行的进程的数据：进程状态、打开的文件、地址空间、信号等等。
5. 造成的主要区别的原因是，早期的Unix机器的内存小，分部处理更加节省空间；而后随着技术进步内存容量得到提升，Linux的处理方式更为高效快速。早期Unix的fork()实现简单且效率低下，Linux做出了改进。

## 进程和线程的区别是什么？Linux是如何实现线程的？

1. 进程是处于执行期的程序和它所包含的资源的总称，线程是进程中的活动对象。
2. 进程是资源管理的最小单位，同一个进程中的所有线程共享资源。
3. 进程至少有一个线程，进程拥有独立的地址空间而线程没有。
4. 线程是程序执行的最小单位，内核调度的对象是线程而不是进程。
5. 采用线程是为了更好的支持SMP（Symmetric Multi-Processor，对称多处理器架构）以及减少上下文切换的开销。线程上下文切换的开销比进程小多了。将同一个进程中的多个线程分配到不同的CPU上执行，在SMP中可以多个CPU执行各个线程，达到最大程度的并行性。

Linux线程的实现：内核把所有的线程都当做进程来实现，线程为视为只与其他进程共享资源的进程。每个线程拥有独立的程序计数器、进程栈和一组进程寄存器，并且拥有唯一的隶属于线程的task_struct。

## Linux进程的状态有哪些？

1. 运行状态（TASK_RUNNING），进程正在被CPU执行，或者准备就绪可由调度程序调度执行。
2. 可中断睡眠状态（TASK_INTERRUPTIBLE），系统不会调度该进程运行。当系统产生一个中断或者释放了进程正在等待的资源，或者进程收到了一个信号，都可以唤醒进程转换到运行状态。
3. 不可中断睡眠状态（TASK_UNINTERRUPTIBLE），只有明确使用wake_up()函数才能唤醒转换到运行状态。
4. 跟踪状态（TASK_TRACED），可被其他进程跟踪。
5. 暂停状态（TASK_STOPPED），收到信号SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU时进入该状态。
6. 僵死状态（TASK_ZOMBIE），进程停止运行，但父进程未询问其状态。
7. 退出状态（TASK_DEAD），即将被销毁。

## 内核的锁的实现方式有哪些？内核只要一个锁就能锁定数据结构，为什么还实现多种方式的锁？

五种锁：原子操作、自旋锁、信号量、BKL（大内核锁）、seq锁（顺序锁）

锁的上下文环境不同、加锁的时间不同、维护锁的开销不同，因此要实现多种锁来应对不同的情况。

1. 原子操作保证指令的执行序列不会被打断，不会被线程调度机制打断。
2. 自旋锁快速简单，适用于加锁时间不长的情形，并且代码不会睡眠。请求锁的进程会不断自选（不会睡眠）。不允许递归
3. 信号量是睡眠锁，适用于加锁时间长并且允许睡眠的情况。
4. BKL锁允许递归，不会出现死锁，但是使用比较少并且有害。
5. seq锁适用于读写共享数据，轻量级，对写者有利，读者循环等待。

## 举例说明内核的某一块设计是利用面向对象技术的

面向对象三个基本特征：封装、继承和多态。封装就是把方法和属性封装起来，实现信息的屏蔽和抽象。继承就是一个对象直接使用另一个对象的属性和方法。多态就是接口有多种不同的实现方式。Linux中多种技术都体现了OO的思想：

1. 文件系统的file对象，file对象只提供了原型而没有提供具体的实现，具体的实现由具体的文件系统提供。内核中重要的数据结构都进行了封装，如文件系统中的inode对象，内存管理中的page对象、cache对象和slab对象等等。
2. 内核中的通用链表结构可以看做是一个基类，基本操作包括节点的插入、删除、初始化和移动，其他的数据结构可以视为它的子类。如果要组织成双向链表，可以包含这个通用链表的对象。内核中使用通用链表的数据结构非常多，包括进程调度、存储器管理、文件系统和网络协议等等。
3. 虚拟文件系统VFS体现了多态性。VFS可以看做是抽象基类，具体的文件系统ext2、VFAT可以看做是它的子类，VFS提供的操作是一个纯虚函数的概念，具体实现由具体的文件系统提供。

## 内核开发的特点

1. 不能访问C库，C库对于内核来说太大了，但是常用的C库函数在内核中都有实现。
2. 必须使用GNU C。
3. 缺乏内存保护机制，内核中的内存不分页。
4. 浮点数很难使用，原则是在内核中不使用。
5. 只有容积很小并且定长的堆栈。
6. 支持异步中断、抢占和SMP，容易出现竞争条件，时刻注意同步和并发，设置同步机制保证不出现竞争条件，使用自旋锁和信号量解决竞争条件。
7. 要注重可移植性。

## 什么是中断上下文，什么是进程上下文，他们之前的区别、联系？中断是否一定要在中断上下文中？

中断上下文：执行一个中断处理程序或者下半部时，内核处于中断上下文。硬件通过触发信号，导致内核进入中断处理程序，硬件的一些变量和参数会传递给内核，内核根据这些参数进行处理。“中断上下文”可以指硬传递过来的变量和参数以及内核需要保存的一些其他环境。

进程上下文：用户空间的进程通过系统调用进入内核空间，需要传递很多的参数和变量给内核，内核也要保存用户进程的一些寄存器值、变量号。“进程上下文”可以指用户进程传递给内核的参数和变量以及内核要保存的那些变量、寄存器值以及环境。

中断上下文没有对应的进程，不可睡眠/阻塞，有一个独立的栈。而进程上下文与一个进程相关，可以睡眠和调用调度器。两者之间没有瓜葛。当执行一个中断服务程序或下半部时，内核一定要在中断上下文中。

## Linux如何实现O(1)调度以及CFS

Linux调度主要在一个运行队列（runqueue）中操作，运行队列中有两个优先级数组（prio_array），定义如下：

```C
struct prio_array
{
    int nr_active; // 任务数目
    unsigned long bitmap[BITMAP_SIZE]; // 优先级位图
    struct list_head queue[MAX_PRIO]; // 优先级队列
}
```

两个数组一个挂着过期的时间片用完的task，另一个挂着活跃的时间片未用完的task。

过程可以参照https://zhuanlan.zhihu.com/p/33461281, https://blog.csdn.net/fangjian1204/article/details/39736725, https://www.ibm.com/developerworks/cn/linux/l-cfs/index.html#artrelatedtopics.

## 系统调用和C库函数的作用，两者的区别？

系统调用的作用：在用户空间和硬件设备之间添加了一个中间层，作用：

1. 为用户空间提供了一种硬件的抽象接口；
2. 保证了系统的稳定和安全；
3. 方便实现多任务和虚拟内存；
4. 系统调用是用户空间进入内核的唯一手段。

C库函数的作用：C库实现了系统主要的API，包括标准C库函数和系统调用。用户只要和库函数打交道就可以使用系统调用访问系统资源。

两者的区别：

1. 系统调用是操作系统的一部分，库函数是语言和应用程序的一部分；
2. 系统调用通常提供一种最小界面，库函数通常提供比较复杂的功能；
3. 系统调用不能被替换，但库函数可以；
4. 应用程序可以调用库函数和系统调用，很多库函数则会调用系统调用，但库函数不是内核的入口点。

## 为什么分上下半部，上半部和下半部的含义是什么？下半部的处理方式有哪些？简述tasklet的思想。

划分上下半部的原因：中断服务程序异步执行，可能会中断其他的重要代码，包括其他中断服务程序。为了避免被中断代码延迟太长的时间，中断服务程序必须尽快进行。所以中断程序只做必要的工作，而把其他的工作推迟到之后进行。Linux中将中断处理划分为两个部分，上半部和下半部。

上半部：中断处理程序，他所要完成的工作越少越好，执行的越快越好。因此只包含一些硬件相关、对时间敏感、保证不能被中断打断的任务。

下半部：剩下的与中断有相关性但是可以被延后处理的任务，比如一些相关数据的操作处理。下半部分延后执行处理且可以响应所有的中断。将系统分为上下半部分可以使得系统处于中断屏蔽的状态的时间尽可能的短，提高系统的响应能力。

实现下半部的方法有很多，使用最多：软中断、tasklet和工作队列。

Tasklet的实现基础是软中断，与软中断的行为很相似。Tasklet内部对软中断实现了封装，外部接口更简单，锁保护的要求更低。Tasklet具有以下的特性：

1. 一种特定类型的tasklet只能运行在一个CPU上，不能并行只能串行；
2. 不同类型的tasklet可以并行运行在多个CPU上；
3. 软中断是静态分配的，内核编译后就不能改变，而tasklet灵活许多，可以在运行时改变。

tasklet是在两种软中断的类型基础上实现的（HI_SOFTIRQ和TASKLET_SOFTIRQ），由于其特殊的规则，降低了驱动程序开发者的负担。如果不需要软中断的并行性，那么tasklet是最好的选择。

注：软中断作为下半部的机制是伴随着SMP应运而生的。它使得对时间不敏感的任务可以延后执行，并且可以在多个CPU上同时执行：软中断在产生后不会立刻执行，必须等待内核的调度才能执行，软中断不能被自己打断，只能被硬件中断打断，唯一能抢占软中断的是上半部；可以并发运行在多个CPU上，软中断必须实现可重入的函数，并且需要使用自旋锁来保护。只有网络/SCSI（**S**mall **C**omputer **S**ystem **I**nterface， 小型计算机系统接口）直接使用软中断——运行频率很高、连续性要求很高、高效完成加锁工作。

## 内核同步方法，为什么要分这几种方法

1. 原子操作：原子的，执行过程中不能被打断的操作，这种操作从一开始执行到最后，中间都不会切换到其他进程；
2. 自旋锁：实现保护共享资源，防止多处理器并发提出的机制。一个执行单位想要获得自旋锁保护的资源必须先得到锁，否则将自旋到得到锁；
3. 信号量：睡眠锁。没有获得信号量的任务进入队列进行睡眠，直到信号量被释放后才被唤醒；在多线程环境下保护关键的代码段不被并行调用。进入一个关键的代码段线程必须获取信号量，执行完成后必须释放信号量；
4. 完成变量：若在内核中的一个任务需要发出信号通知另一个任务发生了某个特定的事件，则使用完成变量。完成变量唤醒在完成变量上等待的任务；
5. BKL：基于小等待自旋锁，全局自旋锁，一个进程可以多次请求BKL（可以递归），保证一个进程只能取得一次锁。在释放前任何锁定的动作都不会导致实质上再次锁定，防止死锁。

多种内核同步的方法，适用于各种不同的场景。

## 1号进程的作用

1号进程就是pid为1的进程，是用户空间第一个被创建的进程，也称为init进程。它完成一系列进程的创建工作，这些进程都是init进程的子孙进程。其在一个死循环中等待这些子进程的退出事件，并调用waitid系统调用来完成“收尸”的工作（清理僵尸进程）。init进程不能被暂停，也不能被杀死。init进程等待进程退出时处于TASK_INTERRUPTIBLE状态，清理僵尸进程时处于TASK_RUNNING状态。

## Linux操作系统实现的是用户级线程还是核心级线程？如何实现？

核心级线程。线程当做进程来实现，与其他进程共享地址空间的进程。拥有独立的程序计数器、进程栈和一组进程寄存器以及一个唯一的隶属于线程的task_struct。

## Open()系统调用做了什么事情

进程要访问一个文件，首先要获取一个文件描述符，通过open系统调用获取这个文件描述符。文件描述符是有限的资源，不用的时候应该释放。该系统调用用来获得欲访问文件的文件描述符，如果文件不存在，则还可以用来创建一个新文件。其函数为sys_open()。

## 操作系统调度的衡量？桌面型和服务器型操作系统各自要强调的地方？

主要指标：吞吐量、响应时间、周转时间、等待时间、cpu利用率和公平性等。

1. 吞吐量：单位时间内CPU完成的作业的数目；
2. 响应时间：作业从提交到系统作出响应做需要的时间；
3. 周转时间：作业从提交到完成所经过的时间，包括等待时间、在就绪队列中排队、在处理器上运行以及进行IO操作的总和；
4. 等待时间：作业在就绪队列中等待的时间；
5. cpu利用率。
6. 公平性：确保每个用户可以获得合理的CPU份额以及其他资源份额，不会使某个进程出现饥饿的状况。

桌面级操作系统的进程一般是IO消耗型的，大部分时间花在提交IO请求和等待IO请求上，不需要长时间片，更强调**响应时间**。而服务器型操作系统一般是CPU消耗型的，大部分之间都花在执行代码上，除非被抢占，否则会不停的运行。需要长时间片，强调的是**吞吐量**。

## Linux伙伴算法是干嘛的？怎么实现？

Linux内核通过伙伴算法来管理物理内存。伙伴系统（Buddy System）理论上是非常简单的内存分配算法。用途：尽可能减少外部碎片，同时允许快速回收和分配物理页面。

实现原理：把所有的页面组织成10个块组，每个组中块的大小为$2^{页面数量}$个页面。第0组：1个页面大小；第2组：4个页面大小。每一组中块的大小是相同的，相同大小的块组织成一个链表。算法工作原理就是从小的块往大的块进行适配，大块适配后会将块剩余的空间插入到小块的链表中。如果没有适合的空闲块就会报错。而块释放的过程就是上述的逆过程，如果有两个块满足：大小相同且物理地址连续，则两个块会合并为一个块插入到大块的链表中，这个过程会不断的迭代。

## 简述Linux内核的特点

Linux是单内核，但汲取了微内核的精华：

1. 动态加载内核模块，可以动态卸除和加载内核代码；
2. 支持对称多处理机制（SMP）；
3. 内核可抢占，内核可以运行更高优先级的任务；
4. 独特的线程实现，不区分线程和进程，都是task；
5. 设备管理提供了具有设备类的面向对象的设备模型、热插拔事件以及用户空间的设备文件系统；
6. 抛弃了Unix中拙劣的stream特性，忽略了一些实际上不会使用的过时的标准；
7. 自由，公开开发模型自由务实发展。

## Linux2.6所实现的调度程序锁实现的目标是什么？

有效性：尽可能完成多的工作；交互性：尽快响应用户；公平性：不允许任何进程饥饿。

1. 充分实现O(1)调度，不管进程数量如何，调度程序使用的算法都能够在恒定的时间内完成。
2. 全面实现了SMP的可扩展性，每个处理器拥有自己的锁和自己的可执行队列。
3. 强化SMP的亲和力，尽量将相关的一组任务分配给同一个CPU执行。
4. 加强交互性能。即使系统处在相当负载的情况下，也能保证系统的响应，立即调度交互式进程。
5. 保证公平。在合理设定的时间范围内，没有进程会饥饿，也没有进程不公平的得到大量的时间片。

## 进程创建的步骤

Linux创建进程大体分为两个步骤：

1. fork()函数负责拷贝当前进程创建一个子进程。
2. exec()函数负责读取可执行文件装入到地址空间中执行。

Linux通过clone()系统调用实现了fork()，clone()调用了do_fork()，do_fork()调用copy_process()。

## 负载平衡程序的操作步骤

Linux为SMP中的每个处理器都准备了单独的可执行队列和锁，而负载平衡程序负责保证这些可执行队列的负载处于平衡状态。负载平衡程序有load_balance()函数实现：

1. 找出最繁忙的可执行队列；
2. 从最繁忙的队列中选择一个优先级数组（过期的优先）以便进行抽取；
3. 选择含有进程的优先级最高的链表；
4. 从链表中选择不在运行并且不在高速缓冲区，可移动的进程抽取；
5. 重复上述步骤直到平衡。

## 用户抢占发生在什么情况？

内核即将返回用户空间的时候，如果need_resched标志被设置，那么就会调用schedule()，此时就会发生用户抢占，因此用户抢占发生在一下两种情况：

1. 从系统调用返回用户空间；
2. 从中断处理程序返回用户空间。

## 内核抢占发生在什么情况？

1. 中断处理程序正在执行，返回内核空间之前；
2. 内核代码再一次变得可抢占（preemt_count为0）；
3. 内核中的任务显示调用schedule()；
4. 内核中的任务阻塞时；

## 请简述SCHED_FIFO与SCHED_RR实时调度的区别

SCHED_FIFO是一种简单的先入先出的调度算法，没有时间片。所有SCHED_FIFO级的进程都比SHCED_NORMAL级的进程都先得到调度。由于SCHED_FIFO不基于时间片，因此只要处于可执行状态，它就会一直执行下去，除非自己阻塞或者主动放弃CPU。只有较高级的SCHED_FIFO或者SCHED_RR进程才能抢占SCHED_FIFO任务。

SCHED_RR与SCHED_FIFO大致相同，但是SCHED_RR受到时间片的限制，在耗尽分配的时间片后就不再接着执行了。也就是一种实时轮转调度的算法。带时间片的SCHED_FIFO。

## 系统调用作为进程与硬件之间的一个中间层所起的作用有哪些？

1. 为用户空间提供了一个硬件的抽象接口；
2. 保证了系统的稳定和安全；
3. 是用户空间进入内核的唯一手段，除了异常和陷入以外的唯一入口。

## 造成并发执行的原因有哪些？

1. 中断：中断可以在任何时刻发生，随时打断当前执行的代码；
2. 软中断和tasklet：内核可能在任何时刻唤醒或者调度软中断和tasklet，打断当前的任务；
3. 内核抢占：内核具有抢占性，在内核中的任务可能会被其他任务抢占；
4. 睡眠以及用户空间的同步：在内核执行的进程可能会睡眠，会唤醒调度程序调度新的一个进程运行；
5. SMP：两个或者多个处理器同时执行代码。

## 请简述在分配内存中，如何选择内存分配函数。

alloc_pages、kmalloc、vmalloc、slab

1. 需要连续的物理页，使用kmalloc()或者低级分配器，常用的内核默认分配方式；
2. 想要从高端的内存进行分配，使用alloc_pages()。
3. 仅仅需要虚拟内存上连续的页，使用vmalloc()。
4. 创建和销毁很大的数据结构，考虑建立slab高速缓存。

## 简述硬链接和软链接之间的区别

Unix下每个文件都有一个相关的数据结构来表述该文件相关的信息，称为inode。创建硬链接就是创建一个inode的指针，不会占用磁盘空间。硬链接上有计数，当计数为0时，文件将会被删除。硬链接有一些限制：不能创建目录的硬链接，防止循环；不能夸文件系统或者分区创建硬链接。

软链接也叫符号链接，本身是一个独立的较小文件，指向新创建的inode，是文件另一个路径的别名。软链接的创建没有限制，但是可能会出现循环的情况。

## 请简述find_vma()、find_vma_prev()以及fine_vma_intersection()之间的区别

find_vma()函数在指定的地址空间中搜索第一个vm_end大于addr的内存区域，也就是找到第一个包含或者大于addr的内存区域，如果没有找到就返回null，否则返回指向匹配的内存区域的vm_area_struct结构体指针。find_vma_prev()则是返回第一个小于addr的内存区域。

fine_vma_intersection()返回第一个和指定地址区间相交的VMA。

## 如何创建地址空间？

用户空间通过mmap()调用内核函数do_mmap()的功能，创建一个新的线性地址空间，如果创建的地址空间和一个已经存在的地址空间相邻，并且拥有相同的访问权限就可以合并。如果不能合并就要创建一个新的VMA了。无论如何，do_mmap()都会将一个地址区间加入到进程的地址空间中。

## 如何删除地址空间？

系统调用munmap()提供了一种从自身地址空间中删除指定地址区间的方法，里面封装了do_munmap()。从指特定的进程地址空间中删除置顶的地址空间。

## 信号量与自旋锁的区别？

信号量：睡眠锁，适用于长时间持有；

自旋锁：忙等待，适用于短时间占有的锁；

## 进程的终结

释放所有物理页面、关闭所有打开的文件以及清楚task[]数组中的相关项。子进程通过系统调用exit()完成前两项，进入僵死状态，然后通知父进程通过调用waitpit()完成最后一项。

## 请简述下半部机制中软中断、tasklet、工作队列的优缺点以及使用场合

软中断：

- 优点：并发运行，可扩展性；
- 缺点：必须使用可重入函数，对锁要求高，复杂度高，静态分配不灵活；
- 场景：时间要求严格、频率高连续性要求高；

tasklet：

- 优点：接口简单，锁保护要求低，同类型的不能并行执行，实现简单，动态灵活性好；
- 缺点：只能串行（同一类）
- 场景：不需要扩展到多CPU的场合

工作队列：

- 缺点：开销大，牵扯到内核线程和上下文切换；
- 场景：中断延期工作运行于进程上下文，工作队列是唯一的选择。